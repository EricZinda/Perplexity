<!doctype html>
<!--
  Minimal Mistakes Jekyll Theme 4.24.0 by Michael Rose
  Copyright 2013-2020 Michael Rose - mademistakes.com | @mmistakes
  Free for personal and commercial use under the MIT license
  https://github.com/mmistakes/minimal-mistakes/blob/master/LICENSE
-->
<html lang="en" class="no-js">
  <head>
    <meta charset="utf-8">

<!-- begin _includes/seo.html --><title>Perplexity</title>
<meta name="description" content="An amazing website.">


  <meta name="author" content="Your Name">
  


<meta property="og:type" content="website">
<meta property="og:locale" content="en_US">
<meta property="og:site_name" content="Perplexity">
<meta property="og:title" content="Perplexity">
<meta property="og:url" content="http://blog.inductorsoftware.com/Perplexity/home/devcon/devcon0040MRSSolverSolutionGroupsAlgorithm/">


  <meta property="og:description" content="An amazing website.">











  

  


<link rel="canonical" href="http://blog.inductorsoftware.com/Perplexity/home/devcon/devcon0040MRSSolverSolutionGroupsAlgorithm/">




<script type="application/ld+json">
  {
    "@context": "https://schema.org",
    
      "@type": "Person",
      "name": "Your Name",
      "url": "http://blog.inductorsoftware.com/Perplexity/home/"
    
  }
</script>







<!-- end _includes/seo.html -->



  <link href="/Perplexity/home/feed.xml" type="application/atom+xml" rel="alternate" title="Perplexity Feed">


<!-- https://t.co/dKP3o1e -->
<meta name="viewport" content="width=device-width, initial-scale=1.0">

<script>
  document.documentElement.className = document.documentElement.className.replace(/\bno-js\b/g, '') + ' js ';
</script>

<!-- For all browsers -->
<link rel="stylesheet" href="/Perplexity/home/assets/css/main.css">
<link rel="preload" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5/css/all.min.css" as="style" onload="this.onload=null;this.rel='stylesheet'">
<noscript><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5/css/all.min.css"></noscript>



    <!-- start custom head snippets -->

<!-- insert favicons. use https://realfavicongenerator.net/ -->

<!-- end custom head snippets -->

  </head>

  <body class="layout--delphin_page wide">
    <nav class="skip-links">
  <ul>
    <li><a href="#site-nav" class="screen-reader-shortcut">Skip to primary navigation</a></li>
    <li><a href="#main" class="screen-reader-shortcut">Skip to content</a></li>
    <li><a href="#footer" class="screen-reader-shortcut">Skip to footer</a></li>
  </ul>
</nav>

    <!--[if lt IE 9]>
<div class="notice--danger align-center" style="margin: 0;">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience.</div>
<![endif]-->

    

<div class="masthead">
  <div class="masthead__inner-wrap">
    <div class="masthead__menu">
      <nav id="site-nav" class="greedy-nav">
        
          <a class="site-logo" href="/Perplexity/home/"><img src="/Perplexity/home/assets/images/Delph-In.png" alt="Perplexity"></a>
        
        <a class="site-title" href="/Perplexity/home/">
          Perplexity
          
        </a>
        <ul class="visible-links"><li class="masthead__menu-item">
              <a href="https://blog.inductorsoftware.com/Perplexity/home/devOverview">Home</a>
            </li></ul>
        
        <button class="search__toggle" type="button">
          <span class="visually-hidden">Toggle search</span>
          <i class="fas fa-search"></i>
        </button>
        
        <button class="greedy-nav__toggle hidden" type="button">
          <span class="visually-hidden">Toggle menu</span>
          <div class="navicon"></div>
        </button>
        <ul class="hidden-links hidden"></ul>
      </nav>
    </div>
  </div>
</div>


    <div class="initial-content">
      





<div id="main" role="main">
  
  <div class="sidebar sticky">
  
  
    
      
      
      
      
    
    
      

<nav class="nav__list">
  
  <input id="ac-toc" name="accordion-toc" type="checkbox" />
  <label for="ac-toc">Toggle Menu</label>
  <ul class="nav__items">
    
      <li>
        
          <span class="nav__sub-title">Developer Tutorial Overview</span>
        

        
        <ul>
          
            <li><a href="/Perplexity/home/devOverview/">Overview</a></li>
          
        </ul>
        
      </li>
    
      <li>
        
          <span class="nav__sub-title">MRS Conceptual</span>
        

        
        <ul>
          
            <li><a href="/Perplexity/home/mrscon/devhowto0010MRS/">Minimal Recursion Semantics (MRS)</a></li>
          
            <li><a href="/Perplexity/home/mrscon/devhowto0020WellFormedTree/">Well-Formed Trees</a></li>
          
        </ul>
        
      </li>
    
      <li>
        
          <span class="nav__sub-title">MRS Solver Conceptual</span>
        

        
        <ul>
          
            <li><a href="/Perplexity/home/devcon/devcon0000Overview/">Overview</a></li>
          
            <li><a href="/Perplexity/home/devcon/devcon0010MRSSolver/">Backtracking</a></li>
          
            <li><a href="/Perplexity/home/devcon/devcon0020MRSSolverSets/">Representing 'Together'</a></li>
          
            <li><a href="/Perplexity/home/devcon/devcon0030MRSSolverSolutionGroups/">Collective, Distributive, Cumulative</a></li>
          
            <li><a href="/Perplexity/home/devcon/devcon0040MRSSolverSolutionGroupsAlgorithm/" class="active">Coll/Dist/Cuml Algorithm</a></li>
          
            <li><a href="/Perplexity/home/devcon/devcon0050MRSSolverSolutionCombinations/">Combinations and Proper Responses</a></li>
          
            <li><a href="/Perplexity/home/devcon/devcon0060WhichParseAndTree/">Choosing a Parse and Tree</a></li>
          
            <li><a href="/Perplexity/home/devcon/devcon0070SentenceForce/">Sentence Types</a></li>
          
            <li><a href="/Perplexity/home/devcon/devcon0080ErrorsChoosingWhichFailure/">Choosing a Failure</a></li>
          
        </ul>
        
      </li>
    
      <li>
        
          <span class="nav__sub-title">Perplexity Internals</span>
        

        
        <ul>
          
            <li><a href="/Perplexity/home/pxint/pxint0000Overview/">Overview</a></li>
          
            <li><a href="/Perplexity/home/pxint/pxint0010PredicationContract/">The Predication Contract</a></li>
          
            <li><a href="/Perplexity/home/pxint/pxint0020PythonBasics/">State and Python Basics</a></li>
          
            <li><a href="/Perplexity/home/pxint/pxint0030ImplementPredication/">Implementing a Predication</a></li>
          
            <li><a href="/Perplexity/home/pxint/pxint0040BuildSolver/">Initial Solver</a></li>
          
            <li><a href="/Perplexity/home/pxint/pxint0050Conjunctions/">Solving Conjunctions</a></li>
          
            <li><a href="/Perplexity/home/pxint/pxint0060ScopalArguments/">Solving Scopal Arguments</a></li>
          
            <li><a href="/Perplexity/home/pxint/pxint0105ErrorsChoosingWhichFailure/">Choosing a Failure</a></li>
          
            <li><a href="/Perplexity/home/pxint/pxint0110ErrorsReportingAFailure/">Naive Failures</a></li>
          
            <li><a href="/Perplexity/home/pxint/pxint0120ErrorsConceptualFailures/">Words in Failures</a></li>
          
            <li><a href="/Perplexity/home/pxint/pxint0130ErrorsRobustFailure/">Robust Failures</a></li>
          
            <li><a href="/Perplexity/home/pxint/pxint0070GenerateMRSAndTrees/">Generating MRS and Trees</a></li>
          
            <li><a href="/Perplexity/home/pxint/pxint0071WhichParseAndTree/">Choosing a Parse and Tree</a></li>
          
            <li><a href="/Perplexity/home/pxint/pxint0080SimplePropositions/">Propositions</a></li>
          
            <li><a href="/Perplexity/home/pxint/pxint0090SimpleQuestions/">Questions</a></li>
          
            <li><a href="/Perplexity/home/pxint/pxint0100SimpleCommands/">Commands</a></li>
          
            <li><a href="/Perplexity/home/pxint/pxint03000PythonDecorators/">A. Python Decorators</a></li>
          
        </ul>
        
      </li>
    
      <li>
        
          <span class="nav__sub-title">Using Perplexity</span>
        

        
        <ul>
          
            <li><a href="/Perplexity/home/pxhowto/pxHowTo010Overview/">Overview</a></li>
          
            <li><a href="/Perplexity/home/pxHowTo/pxHowTo012Install/">Installing Perplexity</a></li>
          
            <li><a href="/Perplexity/home/pxHowTo/pxHowTo014HelloWorld/">Hello World</a></li>
          
            <li><a href="/Perplexity/home/pxhowto/pxHowTo020ImplementAPredication/">Implementing a Predication</a></li>
          
            <li><a href="/Perplexity/home/pxhowto/pxHowTo030InStylePredications/">In-Style Predications</a></li>
          
            <li><a href="/Perplexity/home/pxhowto/pxHowTo040LiftStylePredications/">Lift-Style Predications</a></li>
          
            <li><a href="/Perplexity/home/pxhowto/pxHowTo050EventPredications/">Event Predications</a></li>
          
            <li><a href="/Perplexity/home/pxhowto/pxHowTo070ActionVerbs/">Verb Predications</a></li>
          
            <li><a href="/Perplexity/home/pxhowto/pxHowTo080QuantifiersAndDeterminers/">Quantifiers and Determiners</a></li>
          
            <li><a href="/Perplexity/home/pxhowto/pxHowTo082State/">Custom State</a></li>
          
            <li><a href="/Perplexity/home/pxhowto/pxHowTo085Place/">Representing Places</a></li>
          
            <li><a href="/Perplexity/home/pxhowto/pxHowTo090Prepositions/">Directional Propositions</a></li>
          
        </ul>
        
      </li>
    
  </ul>
</nav>

    
  
  </div>



  <article class="page h-entry" itemscope itemtype="https://schema.org/CreativeWork">
    
    
    
    

    <div class="page__inner-wrap">
      
        <header>
          


        </header>
      

      <section class="page__content e-content" itemprop="text">
        
        <h2 id="solution-group-algorithm">Solution Group Algorithm</h2>
<p>As described in the previous section, the only way to represent the semantics of collective, distributive and cumulative readings of a sentence like:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>students lifted a table

formula: student(x3), table(x10), lift(x3, x10)
scoped formula: scope(x3, [student(x3), scope(x10, [table(y), lift(x3, x10)])])
</code></pre></div></div>

<p>… is to have the solver create groups of solutions (“solution groups”) that are the complete answers – a single solution to the MRS is not enough. This section describes one algorithm that can accomplish this.</p>

<h3 id="overview">Overview</h3>
<p>The basic approach is to generate the solutions, exactly like we’ve been doing so far, but then add a new “grouping pass” afterward. The grouping pass will find the groups of solutions that meet all the <em>numeric constraints</em> that the words in the phrase have placed on the variables. The groups found represent the complete answers to the MRS.</p>

<p>To illustrate what “numeric constraint” means, take “students lifted a table”:</p>
<ul>
  <li>“students …” is plural, which means the contraint is: <code class="language-plaintext highlighter-rouge">count(students) &gt; 2</code></li>
  <li>“… a table” means the constraint is: <code class="language-plaintext highlighter-rouge">count(tables) = 1</code></li>
  <li>etc.</li>
</ul>

<p>To generate solution groups from the flat list of solutions, we could start by generating all combinations of solutions and testing them. For a given combination from the above example: to determine <code class="language-plaintext highlighter-rouge">count(students)</code>, we could simply count the students across all the solutions in the combination. If we do this as well for <code class="language-plaintext highlighter-rouge">count(tables)</code>, and return those combinations where <code class="language-plaintext highlighter-rouge">count(students) &gt; 1</code> and <code class="language-plaintext highlighter-rouge">count(tables) = 1</code>, we will produce groups which <em>are</em> valid, but will miss any answers that require a “per previous value” count. So, we’ll miss the distributive groups. We need to do a slightly more complicated counting algorithm that is “per previous value” to get <em>all</em> the readings.</p>

<p>Here’s an overview of how the algorithm can determine groups that properly account for cumulative, collective and distributive readings:</p>
<blockquote>
  <ol>
    <li>Determine the order variables appear when evaluating the tree</li>
    <li>Walk the variables in order. For each variable: count individuals in the solutions two different ways:
      <ul>
        <li>Cumulatively: Total the variable individuals across all solutions in the group (as above)</li>
        <li>Distributively/collectively: Group the individuals by the value of the previous variable in the order, and then do the total <em>per previous value</em>. If the totals are all the same, across all previous values, that is the count. If not, this count fails and has no value.
          <ul>
            <li>If this is the first variable: there is no “previous variable” to use for the “total per previous value” definition of collective and distributive. Therefore, the first variable can only be totalled as cumulative.</li>
          </ul>
        </li>
      </ul>
    </li>
    <li>If either count meets the variable constraint, it succeeds and the next variable in the order is tried. If not, this group fails.</li>
    <li>If the end is reached and all variables succeeded, this is a valid solution group.</li>
  </ol>
</blockquote>

<p>To get the groups that should be checked using the process above, we (you guessed it…) try every combination of solutions that solving the tree produced. We will end this entire section with ways of efficiently doing this, but we’ll start with the simplistic approach because it is easier to follow and does work, just not efficiently as it could.</p>

<p>Figuring out which constraints are on the variables is a longer story, which the next few sections will cover.</p>

<h3 id="variable-constraints-overview">Variable Constraints Overview</h3>
<p>Notice that every <code class="language-plaintext highlighter-rouge">x</code> variable used in a tree has <em>some kind of</em> numeric constraint applied to it, even if implied. We can model them all using a <code class="language-plaintext highlighter-rouge">between(min, max)</code> (inclusive) constraint with a lower bound and an upper bound. The upper bound can be “inf”, meaning “infinity”.</p>

<p>For “students lifted a table”:</p>
<ul>
  <li>“students …” is plural, which means: <code class="language-plaintext highlighter-rouge">between(2, inf)</code></li>
  <li>“… a table” means: <code class="language-plaintext highlighter-rouge">between(1, 1)</code> (i.e. exactly 1)</li>
</ul>

<p>For “which file is under 2 tables?”:</p>
<ul>
  <li>“… file …” is singular, which means: <code class="language-plaintext highlighter-rouge">between(1, 1)</code></li>
  <li>“… 2 tables …” specifies two, so: <code class="language-plaintext highlighter-rouge">between(2, 2)</code></li>
</ul>

<p><code class="language-plaintext highlighter-rouge">between(1, inf)</code> is the default constraint, meaning: “anything”. Variables with no other constraint get this one – it is implied.</p>

<p>The next section talks about how to extract these constraints from the tree itself.</p>

<h3 id="determining-constraints-from-the-mrs-tree">Determining Constraints From the MRS Tree</h3>
<p>Numeric constraints can come from 3 places in an MRS: quantifiers, adjectives and the plurality property of a variable. Determining constraints will force us to finally start looking at full MRS documents as opposed to simplified MRS fragments that use the artificial <code class="language-plaintext highlighter-rouge">scope()</code> predication we invented in the previous section.</p>

<p>Let’s start with “two students lifted a table”. Here’s one MRS reading of it, along with one well-formed tree:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>[ "two students lifted a table"
  TOP: h0
  INDEX: e2 [ e SF: prop TENSE: past MOOD: indicative PROG: - PERF: - ]
  RELS: &lt; [ udef_q&lt;0:3&gt; LBL: h4 ARG0: x3 [ x PERS: 3 NUM: pl IND: + ] RSTR: h5 BODY: h6 ]
          [ card&lt;0:3&gt; LBL: h7 ARG0: e9 [ e SF: prop TENSE: untensed MOOD: indicative PROG: - PERF: - ] ARG1: x3 CARG: "2" ]
          [ _student_n_of&lt;4:12&gt; LBL: h7 ARG0: x3 ARG1: i10 ]
          [ _lift_v_cause&lt;13:19&gt; LBL: h1 ARG0: e2 ARG1: x3 ARG2: x11 [ x PERS: 3 NUM: sg IND: + ] ]
          [ _a_q&lt;20:21&gt; LBL: h12 ARG0: x11 RSTR: h13 BODY: h14 ]
          [ _table_n_1&lt;22:27&gt; LBL: h15 ARG0: x11 ] &gt;
  HCONS: &lt; h0 qeq h1 h5 qeq h7 h13 qeq h15 &gt; ]

                        ┌── _student_n_of(x3,i10)
            ┌────── and(0,1)
            │             └ card(2,e9,x3)
udef_q(x3,RSTR,BODY)
                 │             ┌────── _table_n_1(x11)
                 └─ _a_q(x11,RSTR,BODY)
                                    └─ _lift_v_cause(e2,x3,x11)

Text Tree: udef_q(x3,[_student_n_of(x3,i10), card(2,e9,x3)],_a_q(x11,_table_n_1(x11),_lift_v_cause(e2,x3,x11)))
</code></pre></div></div>
<p>Two points to note as we transition to using real MRS trees instead of simplified trees:</p>

<ol>
  <li>At this point, we can dispense with the artificial <code class="language-plaintext highlighter-rouge">scope()</code> predication because the MRS quantifier predications (those with <code class="language-plaintext highlighter-rouge">_q</code> at the end) fulfill the same variable scoping role as <code class="language-plaintext highlighter-rouge">scope()</code>. They declare where in the tree a variable can be used.  They <em>also</em> can add numeric constraints to the variable, as we’ll see below.</li>
  <li>Predications in MRS have variable types beyond the <code class="language-plaintext highlighter-rouge">x</code>-type variables we’ve been using. For the examples we’ll see here, these can be safely ignored. We’ll handle those in a later section.</li>
</ol>

<p>With that covered, let’s walk through how to get the numeric constraints from the above MRS.</p>

<h4 id="order-of-variables">Order of Variables</h4>
<p>First, notice that the variable order in this tree is [<code class="language-plaintext highlighter-rouge">x3</code>, <code class="language-plaintext highlighter-rouge">x11</code>] (read left to right) since that is the order of the variable quantifiers when evaluating the tree depth-first.</p>

<h4 id="quantifier-constraints">Quantifier Constraints</h4>
<p>Each variable in an MRS must have a quantifier that scopes it (the artificial <code class="language-plaintext highlighter-rouge">scope()</code> predication performed this function in prior examples), and quantifiers always add a numeric criteria to the variable they scope.  Some, like <code class="language-plaintext highlighter-rouge">udef_q</code> in our example, add the default criteria <code class="language-plaintext highlighter-rouge">between(1, inf)</code>. This simply means: “at least one”. The <code class="language-plaintext highlighter-rouge">_a_q</code> quantifier means “a single thing”, so it adds <code class="language-plaintext highlighter-rouge">between(1, 1)</code>.</p>

<p>Thus, the quantifiers in this example add these constraints:</p>

<table>
  <thead>
    <tr>
      <th><code class="language-plaintext highlighter-rouge">x3</code> (students)</th>
      <th><code class="language-plaintext highlighter-rouge">x11</code>(table)</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">udef</code>: <code class="language-plaintext highlighter-rouge">between(1, inf)</code></td>
      <td><code class="language-plaintext highlighter-rouge">_a_q</code>: <code class="language-plaintext highlighter-rouge">between(1, 1)</code></td>
    </tr>
  </tbody>
</table>

<h4 id="adjective-constraints">Adjective Constraints</h4>
<p>Some adjectives also add numeric constraints. In our example, the adjective “two” gets converted to the predication: <code class="language-plaintext highlighter-rouge">card(2,e9,x3)</code> in the MRS. This predication adds the constraint <code class="language-plaintext highlighter-rouge">between(2, 2)</code> to <code class="language-plaintext highlighter-rouge">x3</code>. Now we have these:</p>

<table>
  <thead>
    <tr>
      <th><code class="language-plaintext highlighter-rouge">x3</code> (students)</th>
      <th><code class="language-plaintext highlighter-rouge">x11</code>(table)</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">udef</code>: <code class="language-plaintext highlighter-rouge">between(1, inf)</code></td>
      <td><code class="language-plaintext highlighter-rouge">_a_q</code>: <code class="language-plaintext highlighter-rouge">between(1, 1)</code></td>
    </tr>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">card</code>: <code class="language-plaintext highlighter-rouge">between(2, 2)</code></td>
      <td> </td>
    </tr>
  </tbody>
</table>

<h4 id="plural-variable-properties">Plural Variable Properties</h4>
<p>Finally, some variables (<code class="language-plaintext highlighter-rouge">x3</code> in our example), are defined to be plural by the MRS, as indicated by <code class="language-plaintext highlighter-rouge">NUM: pl</code> in the variable properties of <code class="language-plaintext highlighter-rouge">x3</code>:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>[ udef_q&lt;0:3&gt; LBL: h4 ARG0: x3 [ x PERS: 3 NUM: pl IND: + ] RSTR: h5 BODY: h6 ]
</code></pre></div></div>

<p>This adds the constraint <code class="language-plaintext highlighter-rouge">between(2, inf)</code> to <code class="language-plaintext highlighter-rouge">x3</code>.</p>

<p><code class="language-plaintext highlighter-rouge">x11</code> from <code class="language-plaintext highlighter-rouge">_table_n_1(x11)</code> is singular based on its variable properties:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>[ _lift_v_cause&lt;13:19&gt; LBL: h1 ARG0: e2 ARG1: x3 ARG2: x11 [ x PERS: 3 NUM: sg IND: + ] ]
</code></pre></div></div>

<p>…  so it adds <code class="language-plaintext highlighter-rouge">between(1, 1)</code>:</p>

<p>Thus, our final list of constraints is:</p>

<table>
  <thead>
    <tr>
      <th><code class="language-plaintext highlighter-rouge">x3</code> (students)</th>
      <th><code class="language-plaintext highlighter-rouge">x11</code>(table)</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">udef</code>: <code class="language-plaintext highlighter-rouge">between(1, inf)</code></td>
      <td><code class="language-plaintext highlighter-rouge">_a_q</code>: <code class="language-plaintext highlighter-rouge">between(1, 1)</code></td>
    </tr>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">card</code>: <code class="language-plaintext highlighter-rouge">between(2, 2)</code></td>
      <td><code class="language-plaintext highlighter-rouge">[NUM: sg]</code>: <code class="language-plaintext highlighter-rouge">between(1, 1)</code></td>
    </tr>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">[NUM: pl]</code>: <code class="language-plaintext highlighter-rouge">between(2, inf)</code></td>
      <td> </td>
    </tr>
  </tbody>
</table>

<h4 id="combining-constraints">Combining Constraints</h4>
<p>The final constraints from the example can be combined.  If <code class="language-plaintext highlighter-rouge">x3</code> must be:</p>
<ul>
  <li>“between 1 and infinity” <em>and</em> “between 2 and infinity” then saying “between 2 and infinity” is enough.</li>
  <li>“between 2 and infinity” <em>and</em> “between 2 and 2 (i.e. exactly 2)” then saying “between 2 and 2” is enough.</li>
</ul>

<p>Using this logic, the final list of constraints above can be reduced to:</p>

<table>
  <thead>
    <tr>
      <th><code class="language-plaintext highlighter-rouge">x3</code> (students)</th>
      <th><code class="language-plaintext highlighter-rouge">x11</code>(table)</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">between(2, 2)</code></td>
      <td><code class="language-plaintext highlighter-rouge">between(1, 1)</code></td>
    </tr>
  </tbody>
</table>

<p>Which matches the intuition that there should be exactly two students and exactly one table (possibly for each student) in “two students lifted a table”.</p>

<h4 id="mrs-constraints-summary">MRS Constraints Summary</h4>
<p>So, now we have an approach to gathering the constraints from the MRS:</p>

<blockquote>
  <p>For each <code class="language-plaintext highlighter-rouge">x</code> variable in the MRS:</p>
  <ol>
    <li>Add the appropriate constraint for its quantifier</li>
    <li>Add any constraints from adjectives that modify it</li>
    <li>Add the <code class="language-plaintext highlighter-rouge">NUM: pl</code> or <code class="language-plaintext highlighter-rouge">NUM: sg</code> constraint</li>
    <li>Reduce them to the minimal set</li>
  </ol>
</blockquote>

<h3 id="the-final-algorithm-introducing-phase-0">The Final Algorithm: Introducing Phase 0</h3>
<p>This section started by describing the two phases of the solver algorithm:</p>
<ul>
  <li>Phase 1: Evaluate the MRS tree to get the solutions</li>
  <li>Phase 2: Group the solutions into solution groups that meet the phrase’s numeric constraints</li>
</ul>

<p>It turns out that the (just described) process of building the numeric constraints is really a “Phase 0”. And, if you think about what adjectives like “two” (or “a few” or “many”) actually <em>do</em>, their entire contribution is to act as a numeric constraint. Their work happens during Phase 2 … they have nothing to do in Phase 1. So, after we extract the criteria from them in Phase 0, they should be <em>removed from the tree</em> and Phase 1 should be solved using the modified tree without them.</p>

<p>Furthermore, recall that quantifiers do two things: scope a variable and add a numeric constraint to the variable. So, after you extract the numeric constraint from quantifiers like <code class="language-plaintext highlighter-rouge">_a_q</code> or <code class="language-plaintext highlighter-rouge">_some_q</code>, you’ve also removed all of their contribution to Phase 1 <em>except for variable scoping</em>. So, we don’t <em>remove</em> them, but we do <em>replace</em> them with the most generic quantifier: <code class="language-plaintext highlighter-rouge">udef_q</code>.</p>

<p>Thus, Phase 0 analyzes a full tree for “2 students lifted a table”, one of which is this:</p>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>                        ┌── _student_n_of(x3,i10)
            ┌────── and(0,1)
            │             └ card(2,e9,x3)
udef_q(x3,RSTR,BODY)
                 │             ┌────── _table_n_1(x11)
                 └─ _a_q(x11,RSTR,BODY)
                                    └─ _lift_v_cause(e2,x3,x11)
</code></pre></div></div>
<p>… but then, after extracting numeric constraints, converts it to a tree without the numeric constraints in it (since those will run in Phase 2), and provides this modified tree to Phase 1:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>            ┌────── _student_n_of(x3,i10)
            │             
udef_q(x3,RSTR,BODY)
                 │               ┌────── _table_n_1(x11)
                 └─ udef_q(x11,RSTR,BODY)
                                      └─ _lift_v_cause(e2,x3,x11)
</code></pre></div></div>

<p>… and finally Phase 3 runs the extracted numeric constraints over the Phase 1 solutions to generate the final solution groups.</p>

<p>Here’s the full algorithm all in one place:</p>

<blockquote>
  <p>Phase 0: Setup</p>
  <ol>
    <li>Start with a well-formed MRS Tree</li>
    <li>Determine the list of <code class="language-plaintext highlighter-rouge">x</code> variables in the tree and the order they will be evaluated in</li>
    <li>Determine the constraints placed on each <code class="language-plaintext highlighter-rouge">x</code> variable by predications that modify it</li>
    <li>Create a modified tree by:
      <ul>
        <li>Removing adjective predications that added numeric constraints</li>
        <li>Changing quantifiers that added numeric constraints to <code class="language-plaintext highlighter-rouge">udef_q</code></li>
      </ul>
    </li>
  </ol>

  <p>Phase 1: Solution Generation</p>

  <ol>
    <li>Generate the list of solutions to the modified tree using the approach described in the previous section</li>
  </ol>

  <p>Phase 2: Group Generation</p>

  <ol>
    <li>For each possible combination of solutions from Phase 1: Walk the <code class="language-plaintext highlighter-rouge">x</code> variables in evaluation order.</li>
    <li>For each <code class="language-plaintext highlighter-rouge">x</code> variable: Count individuals in the solutions two different ways:
      <ul>
        <li>Cumulatively: Total the variable individuals across all solutions in the combination</li>
        <li>Distributive/collectively: Group the individuals by the value of the previous variable in the order, and total individuals in this variable per previous value. If the totals are all the same, across all previous values, that is the count. If not, this count fails and has no value.
          <ul>
            <li>If this is the first variable, there is no “previous variable” to use in the “total per previous value” definition of distributive/collective. Therefore, the first can only be totalled cumulatively</li>
          </ul>
        </li>
      </ul>
    </li>
    <li>If either count meets the variable constraints: it succeeds and the next variable in the order is tried
      <ul>
        <li>If not: this group fails and the next combination group starts at step #5</li>
      </ul>
    </li>
    <li>If the end of the variables is reached and all succeeded, this combination is a valid solution group</li>
  </ol>
</blockquote>

<p>When numeric constraints are removed from an MRS we are left with a relatively straightforward constraint satisfaction problem that should be able to return solutions quickly, but there still may be <em>many</em> solutions.</p>

<h3 id="example">Example</h3>
<p>That can be a lot to take in, so let’s go through an example, “students lifted a table”:</p>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>[ "students lifted a table"
  TOP: h0
  INDEX: e2 [ e SF: prop TENSE: past MOOD: indicative PROG: - PERF: - ]
  RELS: &lt; [ udef_q&lt;0:8&gt; LBL: h4 ARG0: x3 [ x PERS: 3 NUM: pl IND: + ] RSTR: h5 BODY: h6 ]
          [ _student_n_of&lt;0:8&gt; LBL: h7 ARG0: x3 ARG1: i8 ]
          [ _lift_v_cause&lt;9:15&gt; LBL: h1 ARG0: e2 ARG1: x3 ARG2: x9 [ x PERS: 3 NUM: sg IND: + ] ]
          [ _a_q&lt;16:17&gt; LBL: h10 ARG0: x9 RSTR: h11 BODY: h12 ]
          [ _table_n_1&lt;18:23&gt; LBL: h13 ARG0: x9 ] &gt;
  HCONS: &lt; h0 qeq h1 h5 qeq h7 h11 qeq h13 &gt; ]

            ┌────── _student_n_of(x3,i8)
udef_q(x3,RSTR,BODY)          ┌────── _table_n_1(x10)
                 └─ _a_q(x10,RSTR,BODY)
                                   └─ _lift_v_cause(e2,x3,x10)

Text Tree: udef_q(x3,_student_n_of(x3,i8),_a_q(x10,_table_n_1(x10),_lift_v_cause(e2,x3,x10)))
</code></pre></div></div>

<h4 id="phase-0-setup">Phase 0: Setup</h4>
<blockquote>
  <ul>
    <li>Start with a well-formed MRS Tree</li>
    <li>Determine the list of <code class="language-plaintext highlighter-rouge">x</code> variables in the tree and the order they will be evaluated in</li>
    <li>Determine the constraints placed on each <code class="language-plaintext highlighter-rouge">x</code> variable by predications that modify it.</li>
  </ul>
</blockquote>

<p>Using the approach described above, the evaluation order of variables is [<code class="language-plaintext highlighter-rouge">x3</code>, <code class="language-plaintext highlighter-rouge">x10</code>] in a depth-first traversal and the found constraints for the variables are:</p>

<table>
  <thead>
    <tr>
      <th><code class="language-plaintext highlighter-rouge">x3</code> (students)</th>
      <th><code class="language-plaintext highlighter-rouge">x10</code>(table)</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">udef</code>: <code class="language-plaintext highlighter-rouge">between(1, inf)</code></td>
      <td><code class="language-plaintext highlighter-rouge">_a_q</code>: <code class="language-plaintext highlighter-rouge">between(1, 1)</code></td>
    </tr>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">[NUM: pl]</code>: <code class="language-plaintext highlighter-rouge">between(2, inf)</code></td>
      <td><code class="language-plaintext highlighter-rouge">[NUM: sg]</code>: <code class="language-plaintext highlighter-rouge">between(1, 1)</code></td>
    </tr>
  </tbody>
</table>

<p>When simplified, they are:</p>

<table>
  <thead>
    <tr>
      <th><code class="language-plaintext highlighter-rouge">x3</code> (students)</th>
      <th><code class="language-plaintext highlighter-rouge">x10</code>(table)</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">between(2, inf)</code></td>
      <td><code class="language-plaintext highlighter-rouge">between(1, 1)</code></td>
    </tr>
  </tbody>
</table>

<blockquote>
  <ul>
    <li>Create a modified tree by:
      <ul>
        <li>Removing adjective predications that added numeric constraints</li>
        <li>Changing quantifiers that added numeric constraints to <code class="language-plaintext highlighter-rouge">udef_q</code></li>
      </ul>
    </li>
  </ul>
</blockquote>

<p>The modified tree is:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>            ┌────── _student_n_of(x3,i8)
udef_q(x3,RSTR,BODY)             ┌────── _table_n_1(x10)
                 └─ udef_q(x10,RSTR,BODY)
                                      └─ _lift_v_cause(e2,x3,x10)
</code></pre></div></div>

<h4 id="phase-1-solution-generation">Phase 1: Solution Generation</h4>

<blockquote>
  <ul>
    <li>Generate the list of solutions to the modified tree using the approach described in the previous section</li>
  </ul>
</blockquote>

<p>Using a (unshown) world state, and using the approach described in the previous section, the solutions to the modified tree are (let’s say):</p>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>"students lifted a table"

Tree: udef_q(x3,_student_n_of(x3,i8),udef_q(x10,_table_n_1(x10),_lift_v_cause(e2,x3,x10)))

Solution 1: x3=[student1], x10=[table1]                     "student1 is lifting table1"
Solution 2: x3=[student2], x10=[table2]
Solution 3: x3=[student3], x10=[table3]
Solution 4: x3=[student3], x10=[table4]
Solution 5: x3=[student4], x10=[table5]
Solution 6: x3=[student4], x10=[table6]
Solution 7: x3=[student5,student6], x10=[table7]            "student5 and student6 [together] are lifting table7"
Solution 8: x3=[student5,student6], x10=[table8]
Solution 9: x3=[student7,student8], x10=[table9, table10]   "student7 and student8 [together] are lifting table9 and table10 [at the same time]"
Solution 10: x3=[student9], x10=[table11, table12]          "student9 is lifting table11 and table12 [at the same time]"
Solution 11: x3=[student10,student11], x10=[table13]
Solution 12: x3=[student12], x10=[table14]
</code></pre></div></div>

<h4 id="phase-2-group-generation">Phase 2: Group Generation</h4>
<blockquote>
  <ol>
    <li>For each possible combination of solutions from Phase 1: Walk the <code class="language-plaintext highlighter-rouge">x</code> variables in evaluation order.</li>
  </ol>
</blockquote>

<p>Start by generating (as yet untested) groups that are all combinations of the above solutions. These may or may not be solution groups, we don’t know yet: we need to test each one:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Group 1:
  Solution 1: x3=[student1], x10=[table1]                     "student1 is lifting table1"

Group 2:
  Solution 1: x3=[student1], x10=[table1]                     "student1 is lifting table1"
  Solution 2: x3=[student2], x10=[table2]

Group 3:
  Solution 1: x3=[student1], x10=[table1]                     "student1 is lifting table1"
  Solution 2: x3=[student2], x10=[table2]
  Solution 3: x3=[student3], x10=[table3]

... etc. (there are *many* more groups not listed)
</code></pre></div></div>

<blockquote>
  <p>For each group:</p>
  <ul>
    <li>For each <code class="language-plaintext highlighter-rouge">x</code> variable: Count individuals in the solutions two different ways:
      <ul>
        <li>Cumulatively: Total the variable individuals across all solutions</li>
        <li>Distributive/collectively: Group the individuals by the value of the previous variable in the order, and total individuals in this variable per previous value. If the values are all the same, that is the count. If not, this count fails and has no value.
          <ul>
            <li>If this is the first variable, there is no “previous variable” to use in the “total per previous value” definition of distributive/collective. Therefore, the first can only be totalled cumulatively</li>
          </ul>
        </li>
      </ul>
    </li>
    <li>If either count meets the variable constraints: it succeeds and the next variable in the order is tried
      <ul>
        <li>If not: this group fails and the next group starts at step #5</li>
      </ul>
    </li>
    <li>If the end of the variables is reached and all succeeded, this combination is a valid solution group</li>
  </ul>
</blockquote>

<p>Using the constraints we determined:</p>

<table>
  <thead>
    <tr>
      <th><code class="language-plaintext highlighter-rouge">x3</code> (students)</th>
      <th><code class="language-plaintext highlighter-rouge">x10</code>(table)</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">between(2, inf)</code></td>
      <td><code class="language-plaintext highlighter-rouge">between(1, 1)</code></td>
    </tr>
  </tbody>
</table>

<p>… let’s analyze each group:</p>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Group 1:
  Solution 1: x3=[student1], x10=[table1]                     "student1 is lifting table1"
</code></pre></div></div>

<p><code class="language-plaintext highlighter-rouge">x3</code> is the first variable so we only do the cumulative count for it: <code class="language-plaintext highlighter-rouge">cumulative_count=1</code>. The constraint on <code class="language-plaintext highlighter-rouge">x3</code> is <code class="language-plaintext highlighter-rouge">between(2, inf)</code>. Thus: this group fails.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Group 2:
  Solution 1: x3=[student1], x10=[table1]                     "student1 is lifting table1"
  Solution 2: x3=[student2], x10=[table2]
</code></pre></div></div>
<p><code class="language-plaintext highlighter-rouge">x3</code> is the first variable so we only do the cumulative count for it: <code class="language-plaintext highlighter-rouge">cumulative_count=2</code> which passes the constraint <code class="language-plaintext highlighter-rouge">between(2, inf)</code>. Try the next variable.</p>

<p><code class="language-plaintext highlighter-rouge">x10</code> gets both kinds of count:</p>
<ul>
  <li><code class="language-plaintext highlighter-rouge">cumulative_count=2</code>. This fails the <code class="language-plaintext highlighter-rouge">between(1, 1)</code> constraint, but we have one more try…</li>
  <li><code class="language-plaintext highlighter-rouge">dist_coll_count(student1)=1</code>, <code class="language-plaintext highlighter-rouge">dist_coll_count(student2)=1</code>. Both counts are the same so <code class="language-plaintext highlighter-rouge">dist_coll_count=1</code> The constraint on <code class="language-plaintext highlighter-rouge">x10</code> is <code class="language-plaintext highlighter-rouge">between(1, 1)</code>. Thus: this variable succeeds.</li>
</ul>

<p>There are no more variables, thus this group is an answer: a <em>distributive</em> answer.</p>

<p>etc.</p>

<p>All of the groups that succeed are solution groups and will be valid collective, distributive or cumulative readings of the phrase in that world.</p>

<p>There are some subtleties that need to be address with this algorithm. Namely: which of these solution groups to respond to the user with (described in the next section) and global constraints from words like “the” (described in the section after that).</p>

<p>Last update: 2023-05-17 by EricZinda [<a href="https://github.com/EricZinda/Perplexity/edit/main/docs/devcon/devcon0040MRSSolverSolutionGroupsAlgorithm.md">edit</a>]</p>

        
      </section>

      <footer class="page__meta">
        
        


        


      </footer>

      

      
    </div>

    
  </article>

  
  
</div>

<!--Scroll the navbar to the current page-->
<script type="text/javascript">
  let el = document.querySelector('.nav__list .active');
  if(el){
    el.scrollIntoView({block: "center", inline: "start"});
  }
</script>
    </div>

    
      <div class="search-content">
        <div class="search-content__inner-wrap"><form class="search-content__form" onkeydown="return event.key != 'Enter';">
    <label class="sr-only" for="search">
      Enter your search term...
    </label>
    <input type="search" id="search" class="search-input" tabindex="-1" placeholder="Enter your search term..." />
  </form>
  <div id="results" class="results"></div></div>

      </div>
    

    <div id="footer" class="page__footer">
      <footer>
        <!-- start custom footer snippets -->

<!-- end custom footer snippets -->
        <div class="page__footer-follow">
  <ul class="social-icons">
    

    
      
        
      
        
      
        
      
        
      
        
      
        
      
    

    
      <li><a href="/Perplexity/home/feed.xml"><i class="fas fa-fw fa-rss-square" aria-hidden="true"></i> Feed</a></li>
    
  </ul>
</div>

<div class="page__footer-copyright">&copy; 2023 Your Name. Powered by <a href="https://jekyllrb.com" rel="nofollow">Jekyll</a> &amp; <a href="https://mademistakes.com/work/minimal-mistakes-jekyll-theme/" rel="nofollow">Minimal Mistakes</a>.</div>

      </footer>
    </div>

    
  <script src="/Perplexity/home/assets/js/main.min.js"></script>




<script src="/Perplexity/home/assets/js/lunr/lunr.min.js"></script>
<script src="/Perplexity/home/assets/js/lunr/lunr-store.js"></script>
<script src="/Perplexity/home/assets/js/lunr/lunr-en.js"></script>







  </body>
</html>
