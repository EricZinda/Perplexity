<!doctype html>
<!--
  Minimal Mistakes Jekyll Theme 4.24.0 by Michael Rose
  Copyright 2013-2020 Michael Rose - mademistakes.com | @mmistakes
  Free for personal and commercial use under the MIT license
  https://github.com/mmistakes/minimal-mistakes/blob/master/LICENSE
-->
<html lang="en" class="no-js">
  <head>
    <meta charset="utf-8">

<!-- begin _includes/seo.html --><title>Perplexity</title>
<meta name="description" content="An amazing website.">


  <meta name="author" content="Your Name">
  


<meta property="og:type" content="website">
<meta property="og:locale" content="en_US">
<meta property="og:site_name" content="Perplexity">
<meta property="og:title" content="Perplexity">
<meta property="og:url" content="http://blog.inductorsoftware.com/Perplexity/home/pxhowto/pxHowTo095LocativePrepositions/">


  <meta property="og:description" content="An amazing website.">











  

  


<link rel="canonical" href="http://blog.inductorsoftware.com/Perplexity/home/pxhowto/pxHowTo095LocativePrepositions/">




<script type="application/ld+json">
  {
    "@context": "https://schema.org",
    
      "@type": "Person",
      "name": "Your Name",
      "url": "http://blog.inductorsoftware.com/Perplexity/home/"
    
  }
</script>







<!-- end _includes/seo.html -->



  <link href="/Perplexity/home/feed.xml" type="application/atom+xml" rel="alternate" title="Perplexity Feed">


<!-- https://t.co/dKP3o1e -->
<meta name="viewport" content="width=device-width, initial-scale=1.0">

<script>
  document.documentElement.className = document.documentElement.className.replace(/\bno-js\b/g, '') + ' js ';
</script>

<!-- For all browsers -->
<link rel="stylesheet" href="/Perplexity/home/assets/css/main.css">
<link rel="preload" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5/css/all.min.css" as="style" onload="this.onload=null;this.rel='stylesheet'">
<noscript><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5/css/all.min.css"></noscript>



    <!-- start custom head snippets -->

<!-- insert favicons. use https://realfavicongenerator.net/ -->

<!-- end custom head snippets -->

  </head>

  <body class="layout--delphin_page wide">
    <nav class="skip-links">
  <ul>
    <li><a href="#site-nav" class="screen-reader-shortcut">Skip to primary navigation</a></li>
    <li><a href="#main" class="screen-reader-shortcut">Skip to content</a></li>
    <li><a href="#footer" class="screen-reader-shortcut">Skip to footer</a></li>
  </ul>
</nav>

    <!--[if lt IE 9]>
<div class="notice--danger align-center" style="margin: 0;">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience.</div>
<![endif]-->

    

<div class="masthead">
  <div class="masthead__inner-wrap">
    <div class="masthead__menu">
      <nav id="site-nav" class="greedy-nav">
        
          <a class="site-logo" href="/Perplexity/home/"><img src="/Perplexity/home/assets/images/Delph-In.png" alt="Perplexity"></a>
        
        <a class="site-title" href="/Perplexity/home/">
          Perplexity
          
        </a>
        <ul class="visible-links"><li class="masthead__menu-item">
              <a href="https://blog.inductorsoftware.com/Perplexity/home/devOverview">Home</a>
            </li></ul>
        
        <button class="search__toggle" type="button">
          <span class="visually-hidden">Toggle search</span>
          <i class="fas fa-search"></i>
        </button>
        
        <button class="greedy-nav__toggle hidden" type="button">
          <span class="visually-hidden">Toggle menu</span>
          <div class="navicon"></div>
        </button>
        <ul class="hidden-links hidden"></ul>
      </nav>
    </div>
  </div>
</div>


    <div class="initial-content">
      





<div id="main" role="main">
  
  <div class="sidebar sticky">
  
  
    
      
      
      
      
    
    
      

<nav class="nav__list">
  
  <input id="ac-toc" name="accordion-toc" type="checkbox" />
  <label for="ac-toc">Toggle Menu</label>
  <ul class="nav__items">
    
      <li>
        
          <span class="nav__sub-title">Developer Tutorial Overview</span>
        

        
        <ul>
          
            <li><a href="/Perplexity/home/devOverview/">Overview</a></li>
          
        </ul>
        
      </li>
    
      <li>
        
          <span class="nav__sub-title">MRS Conceptual</span>
        

        
        <ul>
          
            <li><a href="/Perplexity/home/mrscon/devhowto0010MRS/">Minimal Recursion Semantics (MRS)</a></li>
          
            <li><a href="/Perplexity/home/mrscon/devhowto0020WellFormedTree/">Well-Formed Trees</a></li>
          
        </ul>
        
      </li>
    
      <li>
        
          <span class="nav__sub-title">MRS Solver Conceptual</span>
        

        
        <ul>
          
            <li><a href="/Perplexity/home/devcon/devcon0000Overview/">Overview</a></li>
          
            <li><a href="/Perplexity/home/devcon/devcon0010MRSSolver/">Backtracking</a></li>
          
            <li><a href="/Perplexity/home/devcon/devcon0020MRSSolverSets/">Representing 'Together'</a></li>
          
            <li><a href="/Perplexity/home/devcon/devcon0030MRSSolverSolutionGroups/">Collective, Distributive, Cumulative</a></li>
          
            <li><a href="/Perplexity/home/devcon/devcon0040MRSSolverSolutionGroupsAlgorithm/">Coll/Dist/Cuml Algorithm</a></li>
          
            <li><a href="/Perplexity/home/devcon/devcon0050MRSSolverSolutionCombinations/">Combinations and Proper Responses</a></li>
          
            <li><a href="/Perplexity/home/devcon/devcon0060WhichParseAndTree/">Choosing a Parse and Tree</a></li>
          
            <li><a href="/Perplexity/home/devcon/devcon0070SentenceForce/">Sentence Types</a></li>
          
            <li><a href="/Perplexity/home/devcon/devcon0080ErrorsChoosingWhichFailure/">Choosing a Failure</a></li>
          
        </ul>
        
      </li>
    
      <li>
        
          <span class="nav__sub-title">Perplexity Internals</span>
        

        
        <ul>
          
            <li><a href="/Perplexity/home/pxint/pxint0000Overview/">Overview</a></li>
          
            <li><a href="/Perplexity/home/pxint/pxint0010PredicationContract/">The Predication Contract</a></li>
          
            <li><a href="/Perplexity/home/pxint/pxint0020PythonBasics/">State and Python Basics</a></li>
          
            <li><a href="/Perplexity/home/pxint/pxint0030ImplementPredication/">Implementing a Predication</a></li>
          
            <li><a href="/Perplexity/home/pxint/pxint0040BuildSolver/">Initial Solver</a></li>
          
            <li><a href="/Perplexity/home/pxint/pxint0050Conjunctions/">Solving Conjunctions</a></li>
          
            <li><a href="/Perplexity/home/pxint/pxint0060ScopalArguments/">Solving Scopal Arguments</a></li>
          
            <li><a href="/Perplexity/home/pxint/pxint0105ErrorsChoosingWhichFailure/">Choosing a Failure</a></li>
          
            <li><a href="/Perplexity/home/pxint/pxint0110ErrorsReportingAFailure/">Naive Failures</a></li>
          
            <li><a href="/Perplexity/home/pxint/pxint0120ErrorsConceptualFailures/">Words in Failures</a></li>
          
            <li><a href="/Perplexity/home/pxint/pxint0130ErrorsRobustFailure/">Robust Failures</a></li>
          
            <li><a href="/Perplexity/home/pxint/pxint0070GenerateMRSAndTrees/">Generating MRS and Trees</a></li>
          
            <li><a href="/Perplexity/home/pxint/pxint0071WhichParseAndTree/">Choosing a Parse and Tree</a></li>
          
            <li><a href="/Perplexity/home/pxint/pxint0080SimplePropositions/">Propositions</a></li>
          
            <li><a href="/Perplexity/home/pxint/pxint0090SimpleQuestions/">Questions</a></li>
          
            <li><a href="/Perplexity/home/pxint/pxint0100SimpleCommands/">Commands</a></li>
          
            <li><a href="/Perplexity/home/pxint/pxint03000PythonDecorators/">A. Python Decorators</a></li>
          
        </ul>
        
      </li>
    
      <li>
        
          <span class="nav__sub-title">Using Perplexity</span>
        

        
        <ul>
          
            <li><a href="/Perplexity/home/pxhowto/pxHowTo010Overview/">Overview</a></li>
          
            <li><a href="/Perplexity/home/pxHowTo/pxHowTo012Install/">Installing Perplexity</a></li>
          
            <li><a href="/Perplexity/home/pxHowTo/pxHowTo014HelloWorld/">Hello World</a></li>
          
            <li><a href="/Perplexity/home/pxhowto/pxHowTo020ImplementAPredication/">Implementing a Predication</a></li>
          
            <li><a href="/Perplexity/home/pxhowto/pxHowTo030InStylePredications/">In-Style Predications</a></li>
          
            <li><a href="/Perplexity/home/pxhowto/pxHowTo040LiftStylePredications/">Lift-Style Predications</a></li>
          
            <li><a href="/Perplexity/home/pxhowto/pxHowTo050EventPredications/">Event Predications</a></li>
          
            <li><a href="/Perplexity/home/pxhowto/pxHowTo070ActionVerbs/">Verb Predications</a></li>
          
            <li><a href="/Perplexity/home/pxhowto/pxHowTo080QuantifiersAndDeterminers/">Quantifiers and Determiners</a></li>
          
            <li><a href="/Perplexity/home/pxhowto/pxHowTo082State/">Custom State</a></li>
          
            <li><a href="/Perplexity/home/pxhowto/pxHowTo085Place/">Representing Places</a></li>
          
            <li><a href="/Perplexity/home/pxhowto/pxHowTo090Prepositions/">Directional Propositions</a></li>
          
            <li><a href="/Perplexity/home/pxhowto/pxHowTo095LocativePrepositions/" class="active">Locative Propositions</a></li>
          
        </ul>
        
      </li>
    
  </ul>
</nav>

    
  
  </div>



  <article class="page h-entry" itemscope itemtype="https://schema.org/CreativeWork">
    
    
    
    

    <div class="page__inner-wrap">
      
        <header>
          


        </header>
      

      <section class="page__content e-content" itemprop="text">
        
        <h2 id="verbs-and-locative-prepositions">Verbs and Locative Prepositions</h2>
<p>Locative prepositions like “in” specify the location of something, but they can be used in several different ways. We’ll examine them via the phrase:</p>

<blockquote>
  <p>copy “foo” in “/documents”</p>
</blockquote>

<p>There are 171 different parses that the ERG provides since there is a lot of ambiguity in this phrase.  Here, we’ll focus on the parses that use “copy” as a verb along with “in” as a preposition. Shown below are 4 different patterns (aka <em>phenomena</em>) that appear. They are listed showing the form of the “in” and “copy” predications, along with their interpretation:</p>

<ol>
  <li>
    <p><code class="language-plaintext highlighter-rouge">_in_p_loc(e15,x8,x16), _copy_v_1(e2,x3,x8)</code>: Copy the ‘foo’ that is in ‘documents’ [where to copy <em>to</em> is not specified]</p>

    <p>This version of “in” has already been implemented in the <a href="https://blog.inductorsoftware.com/Perplexity/home/pxhowto/pxHowTo030InStylePredications">In-style Predications topic</a> and doesn’t need modification. It takes two <code class="language-plaintext highlighter-rouge">x</code> arguments and restricts them: <code class="language-plaintext highlighter-rouge">x8</code> must be something that is “in” <code class="language-plaintext highlighter-rouge">x16</code>. This is a “locative” form of the “in” preposition that specifies where something is.  So, <code class="language-plaintext highlighter-rouge">in_p_loc</code> indicates where to find <code class="language-plaintext highlighter-rouge">x8</code> (in <code class="language-plaintext highlighter-rouge">x16</code>), and <code class="language-plaintext highlighter-rouge">copy_v_1</code> simply needs to copy <code class="language-plaintext highlighter-rouge">x8</code>…somewhere.  <em>Where</em> is not specified.</p>
  </li>
  <li>
    <p><code class="language-plaintext highlighter-rouge">_in_p_state(e13,e2,x14), _copy_v_1(e2,x3,x8)</code>: Copy ‘foo’, and do the copy from within ‘/documents’ [<em>where</em> to copy and where ‘foo’ <em>is</em> are not specified]</p>

    <p>This reading has a version of “in” that takes the <code class="language-plaintext highlighter-rouge">e2</code> event for its second arg, and <code class="language-plaintext highlighter-rouge">e2</code> is introduced by <code class="language-plaintext highlighter-rouge">_copy_v_1</code>. As described in the <a href="https://blog.inductorsoftware.com/Perplexity/home/pxhowto/pxHowTo090Prepositions">Directional Prepositions topic</a>, this means that <code class="language-plaintext highlighter-rouge">in_p_state</code> is providing information to <code class="language-plaintext highlighter-rouge">_copy_v_1</code> about how to go about copying. But, unlike directional prepositions described in that topic, <code class="language-plaintext highlighter-rouge">_state</code> in the predication name indicates that the preposition is used in a “stative” sense. This means it is specifying where the verb is <em>taking place</em>. So this phrase says that the “copying” should be done “in the location specified by <code class="language-plaintext highlighter-rouge">x4</code>”.  Where to copy <em>to</em> is not specified.</p>
  </li>
  <li>
    <p><code class="language-plaintext highlighter-rouge">_copy_v_1(e2,x3,x8,_in_p_loc(e15,x8,x16))</code>: Copy ‘foo’ such that it ends up in ‘/documents’</p>

    <p>This version of <code class="language-plaintext highlighter-rouge">_copy_v_1</code> has a scopal argument which contains the “in” preposition. As discussed in the <a href="https://blog.inductorsoftware.com/Perplexity/home/mrscon/devhowto0010MRS">MRS Overview</a>, scopal arguments occur when the predication needs to do something special with the branch of the tree it is passed.  In this case, <code class="language-plaintext highlighter-rouge">_copy_v_1</code> is being asked to change the world such that the branch it is being passed (i.e. <code class="language-plaintext highlighter-rouge">_in_p_loc(e15,x8,x16)</code>) is <code class="language-plaintext highlighter-rouge">true</code>. Since <code class="language-plaintext highlighter-rouge">x8</code> is “foo” and <code class="language-plaintext highlighter-rouge">x16</code> is “/documents”, <code class="language-plaintext highlighter-rouge">_copy_v_1</code> should make “foo” be “in” “/documents”.</p>
  </li>
  <li>
    <p>(not used in this example) <code class="language-plaintext highlighter-rouge">_preposition_p_dir(e,e1,x), verb_v(e1, ...)</code></p>

    <p>There is another variation of the predication for “in” that the ERG doesn’t generate for this example, but was shown in <a href="https://blog.inductorsoftware.com/Perplexity/home/pxhowto/pxHowTo070ActionVerbs">the topic on <code class="language-plaintext highlighter-rouge">go_v_1</code></a>. Look at the two interpretations of “the mouse is running under the table”:</p>

    <p>(stative) Just like example 1 above: The mouse staying under the table and running around there:</p>
  </li>
</ol>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>                ┌────── _mouse_n_1(x3)
    _the_q(x3,RSTR,BODY)            ┌────── _table_n_1(x9)
                    └─ _the_q(x9,RSTR,BODY)    ┌── _under_p_state(e8,e2,x9)
                                        └─ and(0,1)
                                                └ _run_v_1(e2,x3)
</code></pre></div></div>

<p>(directional) Just like <a href="https://blog.inductorsoftware.com/Perplexity/home/pxhowto/pxHowTo070ActionVerbs"><code class="language-plaintext highlighter-rouge">to_p_dir</code> in the topic on <code class="language-plaintext highlighter-rouge">go_v_1</code></a>: The mouse moving from some other spot in the room on a path that takes it under the table:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>                ┌────── _table_n_1(x9)
    _the_q(x9,RSTR,BODY)            ┌────── _mouse_n_1(x3)
                    └─ _the_q(x3,RSTR,BODY)    ┌── _under_p_dir(e8,e2,x9)
                                        └─ and(0,1)
                                                └ _run_v_1(e2,x3)
</code></pre></div></div>

<p>So, we’ve seen 4 ways that MRS can use a locative preposition with a verb that takes a direction:</p>

<ol>
  <li>(locative) <code class="language-plaintext highlighter-rouge">preposition_p_loc(e,x1,x2), verb_v(..., x1)</code>: The verb should do what it does with whatever the preposition put in <code class="language-plaintext highlighter-rouge">x1</code></li>
  <li>(stative) <code class="language-plaintext highlighter-rouge">_preposition_p_state(e,e1,x2), verb_v(e1, ...)</code>: The actor or verb is happening at the place indicated by whatever the preposition put in <code class="language-plaintext highlighter-rouge">x2</code></li>
  <li>(scopal) <code class="language-plaintext highlighter-rouge">verb_v(..., preposition_p_loc(e,x,x))</code>: The verb should make this preposition true via what it does</li>
  <li>(directional) <code class="language-plaintext highlighter-rouge">_preposition_p_dir(e,e1,x), verb_v(e1, ...)</code>: The actor or verb are happening in that direction</li>
</ol>

<p>We already have the locative version of “in” (#1) <a href="https://blog.inductorsoftware.com/Perplexity/home/pxhowto/pxHowTo030InStylePredications">implemented</a>, so let’s start there.</p>

<h3 id="1-_in_p_loce15x8x16-_copy_v_1e2x3x8-copy-the-foo-that-is-in-documents">1. <code class="language-plaintext highlighter-rouge">_in_p_loc(e15,x8,x16), _copy_v_1(e2,x3,x8)</code>: Copy the ‘foo’ that is in ‘documents’</h3>
<p>Here is the version of <code class="language-plaintext highlighter-rouge">_in_p_loc</code> that we implemented in the section on <a href="https://blog.inductorsoftware.com/Perplexity/home/pxhowto/pxHowTo030InStylePredications">In-style Predications</a>, but updated using the new <code class="language-plaintext highlighter-rouge">FileSystemState</code> object instead of placeholder methods:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>@Predication(vocabulary, names=["_in_p_loc"])
def in_p_loc(state, e_introduced_binding, x_actor_binding, x_location_binding):
    def item_in_item(item1, item2):
        # x_actor is "in" x_location if x_location contains it
        found_location = False
        if hasattr(item2, "contained_items"):
            for item in item2.contained_items(x_location_binding.variable):
                if item1 == item:
                    found_location = True
                    break

        if not found_location:
            report_error(["thingHasNoLocation", x_actor_binding.variable.name, x_location_binding.variable.name])

        return found_location

    def location_unbound_values(actor_value):
        # This is a "what is actor in?" type query since no location specified (x_location_binding was unbound)
        # Order matters, so all_locations needs to return the best answer first
        if hasattr(actor_value, "all_locations"):
            for location in actor_value.all_locations(x_actor_binding.variable):
                yield location

        report_error(["thingHasNoLocation", x_actor_binding.variable.name, x_location_binding.variable.name])

    def actor_unbound_values(location_value):
        # This is a "what is in x?" type query since no actor specified (x_actor_binding was unbound)
        # Order matters, so all_locations needs to return the best answer first
        if hasattr(location_value, "contained_items"):
            for actor in location_value.contained_items(x_location_binding.variable):
                yield actor
        else:
            report_error(["thingIsNotContainer", x_location_binding.variable.name])

    yield from in_style_predication_2(state, x_actor_binding, x_location_binding, item_in_item, actor_unbound_values, location_unbound_values)

    report_error(["thingHasNoLocation", x_actor_binding.variable.name, x_location_binding.variable.name])
</code></pre></div></div>

<p>To make this work:</p>

<blockquote>
  <p>copy “file1.txt” in “/documents”</p>
</blockquote>

<p>… we only need to implement <code class="language-plaintext highlighter-rouge">_copy_v_1(e,x,x)</code>.  It will work very much <a href="">like <code class="language-plaintext highlighter-rouge">_delete_v_1</code></a>:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code># "copy" where the user did not say where to copy to, assume current directory
@Predication(vocabulary, names=["_copy_v_1"])
def copy_v_1_comm(state, e_introduced_binding, x_actor_binding, x_what_binding):
    # We only know how to copy things from the
    # computer's perspective
    if x_actor_binding.value.name == "Computer":
        # Only allow copying files and folders
        if isinstance(x_what_binding.value, (File, Folder)):
            yield state.apply_operations([CopyOperation(None, x_what_binding, None)])

        else:
            report_error(["cantDo", "copy", x_what_binding.variable.name])

    else:
        report_error(["dontKnowActor", x_actor_binding.variable.name])
        
        
class CopyOperation(object):
    def __init__(self, binding_from_copy, binding_to_copy):
        self.binding_from_copy = binding_from_copy
        self.binding_to_copy = binding_to_copy

    def apply_to(self, state):
        if isinstance(state, FileSystemState):
            state.file_system.copy_item(self.binding_from_copy, self.binding_to_copy)
            
            
class FileSystemMock(FileSystem):

    ...
    
    def copy_item(self, from_binding, to_binding):
        if self.exists(from_binding.value.name, is_file=isinstance(from_binding.value, File)):
            if to_binding is None:
                to_binding = VariableBinding(None, self.current_directory())

            if self.exists(to_binding.value.name, is_file=isinstance(to_binding.value, File)):
                item_name = pathlib.PurePath(from_binding.value.name).parts[-1]
                if isinstance(to_binding.value, Folder):
                    # "to" is a folder, use it as the new base for the file name
                    new_item_path = pathlib.PurePath(to_binding.value.name, item_name)

                else:
                    # "to" includes a file name, use the entire name as the name of the target
                    new_item_path = to_binding.value.name

                new_item = copy.deepcopy(self.item_from_path(from_binding.value.name, is_file=isinstance(from_binding.value, File)))
                new_item.name = new_item_path
                self.items[str(new_item_path)] = new_item

            else:
                raise MessageException("notFound", [to_binding.variable.name])

        else:
            raise MessageException("notFound", [from_binding.variable.name])
</code></pre></div></div>

<p>Now we can copy a file:</p>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>? what is in this folder?
File(name=/Desktop/the yearly budget.txt, size=10000000)
File(name=/Desktop/blue, size=1000)

? copy "file1.txt" in "/documents"
Done!

? what is in this folder?
File(name=/Desktop/the yearly budget.txt, size=10000000)
File(name=/Desktop/blue, size=1000)
File(name=/Desktop/file1.txt, size=1000)
</code></pre></div></div>

<p>In this case, “copy ‘file1.txt’ in ‘/documents’” is interpreted as “copy the file ‘/documents/file1.txt’ to my current directory” since “in” is interpreted as applying to where the file is and where to copy <em>to</em> isn’t specified.</p>

<h3 id="2-_in_p_statee13e2x14-_copy_v_1e2x3x8-copy-foo-and-do-the-copy-from-within-documents">2. <code class="language-plaintext highlighter-rouge">_in_p_state(e13,e2,x14), _copy_v_1(e2,x3,x8)</code>: Copy ‘foo’, and do the copy from within ‘/documents’</h3>

<p>Next up we’ll tackle the stative version of “in”. Recall that “stative” means where the verb is “happening” and so it tells <code class="language-plaintext highlighter-rouge">_copy_v_1</code> where to do the copying <em>from</em>.</p>

<p>This will work exactly the same as the previous example if there is a relative file name. That is because “doing the copy from within ‘documents’” sets the current directory to “/documents” and the previous inteprets the file itself “in” documents. Both approaches resolve to the same file. However, an absolute file name should work here (since current directory is not used when calculating an absolute file name) but should <em>not</em> work in the above example (since the absolute path won’t be “in” that directory).</p>

<p>Here’s the code for stative “in” and a version of “copy” that uses it:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>@Predication(vocabulary, names=["_in_p_state"])
def in_p_state(state, e_introduced_binding, e_target_binding, x_location_binding):
    preposition_info = {
        "EndLocation": x_location_binding
    }

    yield state.add_to_e(e_target_binding.variable.name, "StativePreposition", {"Value": preposition_info, "Originator": execution_context().current_predication_index()})


# "copy" where the user specifies where to copy "from". Assume "to" is current directory since it isn't specified
# This is really only different from the locative "_in_p_loc(e15,x8,x16), _copy_v_1(e2,x3,x8)" version if:
# a) The from directory doesn't exist
# b) The thing to copy has a relative path because our "current directory" for the file will be different
@Predication(vocabulary, names=["_copy_v_1"], handles=[("StativePreposition", EventOption.required)])
def stative_copy_v_1_comm(state, e_introduced_binding, x_actor_binding, x_what_binding):
    x_copy_from_location_binding = e_introduced_binding.value["StativePreposition"]["Value"]["EndLocation"]

    # We only know how to copy things from the
    # computer's perspective
    if x_actor_binding.value.name == "Computer":
        # We only know how to copy something "from" a folder
        if isinstance(x_copy_from_location_binding.value, Folder):
            # Only allow copying files and folders
            if isinstance(x_what_binding.value, (File, Folder)):
                yield state.apply_operations([CopyOperation(x_copy_from_location_binding, x_what_binding, None)])

            else:
                report_error(["cantDo", "copy", x_what_binding.variable.name])

        else:
            report_error(["cantDo", "copy from", x_what_binding.variable.name])

    else:
        report_error(["dontKnowActor", x_actor_binding.variable.name])
</code></pre></div></div>
<p>We’re using the same pattern in <code class="language-plaintext highlighter-rouge">_in_p_state</code> that we used for <code class="language-plaintext highlighter-rouge">_in_p_dir</code> in a previous topic: the preposition is just adding its information to the event it is passed, and the verb that introduced that event consumes the information to do its job.</p>

<p><code class="language-plaintext highlighter-rouge">FileSystemMock.copy_item()</code> only changed to use a “copy from” directory to set the base of a relative file name:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>class FileSystemMock(FileSystem):
    
    ...
    
    def copy_item(self, from_directory_binding, from_binding, to_binding):
        if from_directory_binding is not None:
            # PurePath will only attach the from_directory_binding.value.name to the front if
            # if from_binding.value is relative, otherwise it is ignored
            from_path = str(pathlib.PurePath(from_directory_binding.value.name, from_binding.value.name))
        else:
            from_path = from_binding.value.name
</code></pre></div></div>

<p>With that in place, we can try two different phrases.  One that will work with the locative “in” we implemented first, and one that will only work with the stative “in”. Since the system will stop once an MRS succeeds, and since the parse for the locative “in” gets executed first, we’ll be able to see if the locative “in” really doesn’t work (and the new one does):</p>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>? copy "file1.txt" in "/documents"
Done!

? /show

...

                           ┌── quoted(\\&gt;documents,i21)
               ┌────── and(0,1)
               │             └ fw_seq(x16,i21)
               │                                                        ┌──── _in_p_loc(e15,x8,x16)
proper_q(x16,RSTR,BODY)                                                 │
                    │                                                   │ ┌── quoted(file1.txt,i13)
                    │                                       ┌────── and(0,1,2)
                    │                 ┌────── pron(x3)      │               │
                    │                 │                     │               └ fw_seq(x8,i13)
                    └─ pronoun_q(x3,RSTR,BODY)              │
                                           └─ proper_q(x8,RSTR,BODY)
                                                                 └─ _copy_v_1(e2,x3,x8)

...

? copy "/Desktop/blue" in "/documents"
Done!

? /show

...

                           ┌── quoted(\\&gt;documents,i21)
               ┌────── and(0,1)
               │             └ fw_seq(x16,i21)
proper_q(x16,RSTR,BODY)                                                 ┌── quoted(\\&gt;Desktop\\&gt;blue,i13)
                    │                                       ┌────── and(0,1)
                    │                 ┌────── pron(x3)      │             └ fw_seq(x8,i13)
                    └─ pronoun_q(x3,RSTR,BODY)              │
                                           └─ proper_q(x8,RSTR,BODY)
                                                                 │      ┌── _in_p_state(e15,e2,x16)
                                                                 └─ and(0,1)
                                                                          └ _copy_v_1(e2,x3,x8)
                                                                          
...
</code></pre></div></div>

<p>Now we have two interpretations of “in” working, let’s move on to the third which is more involved.</p>

<h3 id="3-_copy_v_1e2x3x8_in_p_loce15x8x16-copy-foo-such-that-it-ends-up-in-documents">3. <code class="language-plaintext highlighter-rouge">_copy_v_1(e2,x3,x8,_in_p_loc(e15,x8,x16))</code>: Copy ‘foo’ such that it ends up in ‘/documents’</h3>

<p>This version of <code class="language-plaintext highlighter-rouge">_copy_v_1</code> takes a scopal argument which contains the “in” preposition. As discussed in the topic on scopal arguments, scopal arguments occur in places where the predication needs to do something special with the branch of the tree it is passed.  In this case, <code class="language-plaintext highlighter-rouge">_copy_v_1</code> is being asked to “make <code class="language-plaintext highlighter-rouge">_in_p_loc(e15,x8,x16)</code> be true”, meaning: change the world such that <code class="language-plaintext highlighter-rouge">_in_p_loc(e15,x8,x16)</code>. Since <code class="language-plaintext highlighter-rouge">x8</code> is “foo” and <code class="language-plaintext highlighter-rouge">x16</code> is “/documents”, <code class="language-plaintext highlighter-rouge">_copy_v_1</code> should make “foo” be “in /documents”.</p>

<p>Here are two other examples of verbs taking scopal arguments to illustrate:</p>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>put the vase on the table

            ┌────── _vase_n_1(x8)
_the_q(x8,RSTR,BODY)             ┌────── _table_n_1(x16)
                 └─ _the_q(x16,RSTR,BODY)               ┌────── pron(x3)
                                      └─ pronoun_q(x3,RSTR,BODY)                    ┌─ _on_p_loc(e15,x8,x16)
                                                             └─ _put_v_1(e2,x3,x8,ARG3)
                                                             
paint the tree green

            ┌────── _tree_n_of(x8,i14)
_the_q(x8,RSTR,BODY)               ┌────── pron(x3)
                 └─ pronoun_q(x3,RSTR,BODY)                      ┌─ _green_a_2(e16,x8)
                                        └─ _paint_v_1(e2,x3,x8,ARG3)
</code></pre></div></div>

<p>In all these cases, the verb using a scopal argument because they all examples of a phrase taking something in the world and changing it. This type of scenario needs a scopal argument because a normal predication would attempt to find a “foo” that <em>is</em> in “/documents” … and that is not true yet. The scopal argument doesn’t get evaluated normally (as we’ll see below), so it avoids this problem.</p>

<p>So, verbs with scopal arguments have to do what they do in such a way that their scopal argument becomes true. This can all seem wonderfully abstract if you try to imagine how to write code which “paints x in a way that makes any possible thing true”, but the approach we’re going to take here is much more concrete: Break down each scenario we are focused on for a given verb and implement that.</p>

<p>For example, for “copy ‘foo’ in ‘/documents’”, the scopal argument is a locative preposition:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>                          ┌── quoted(foo,i14)
              ┌────── and(0,1)
              │             └ fw_seq(x8,i14)
proper_q(x8,RSTR,BODY)                           ┌── quoted(/documents,i23)
                   │                 ┌────── and(0,1)
                   │                 │             └ fw_seq(x18,i23)
                   └─ proper_q(x18,RSTR,BODY)
                                          │                 ┌────── pron(x3)
                                          └─ pronoun_q(x3,RSTR,BODY)                     ┌─ _in_p_loc(e17,x8,x18)
                                                                 └─ _copy_v_1(e2,x3,x8,ARG3)
</code></pre></div></div>

<p>So, we can implement a version of <code class="language-plaintext highlighter-rouge">_copy_v_1</code> that knows how to deal with locative prepositions. If we do it carefully, it will work with all kind of locative prepositions.</p>

<p>Here’s how: Note that the following examples all have the same structure even though they use different locative prepositions, only the preposition is different:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>&gt; copy "foo" into "/documents"

                          ┌── quoted(foo,i14)
              ┌────── and(0,1)
              │             └ fw_seq(x8,i14)
proper_q(x8,RSTR,BODY)                           ┌── quoted(/documents,i23)
                   │                 ┌────── and(0,1)
                   │                 │             └ fw_seq(x18,i23)
                   └─ proper_q(x18,RSTR,BODY)
                                          │                 ┌────── pron(x3)
                                          └─ pronoun_q(x3,RSTR,BODY)                     ┌─ _into_p(e17,x8,x18)
                                                                 └─ _copy_v_1(e2,x3,x8,ARG3)


&gt; copy "foo" above "/documents"

                          ┌── quoted(foo,i14)
              ┌────── and(0,1)
              │             └ fw_seq(x8,i14)
proper_q(x8,RSTR,BODY)                           ┌── quoted(/documents,i23)
                   │                 ┌────── and(0,1)
                   │                 │             └ fw_seq(x18,i23)
                   └─ proper_q(x18,RSTR,BODY)
                                          │                 ┌────── pron(x3)
                                          └─ pronoun_q(x3,RSTR,BODY)                     ┌─ _above_p(e17,x8,x18)
                                                                 └─ _copy_v_1(e2,x3,x8,ARG3)
</code></pre></div></div>

<p>We need a mechanism that converts scopal predications into a generic form so all of the examples above can be handled in the same way. This form should allow <code class="language-plaintext highlighter-rouge">_copy_v_1</code> to avoid special casing every single locative preposition.</p>

<p>To do this, we can’t just <code class="language-plaintext highlighter-rouge">call()</code> with the scopal argument <code class="language-plaintext highlighter-rouge">_in_p_loc(e17,x8,x18)</code> (as we do for quantifiers) – it will fail since it isn’t true yet. “foo” is not yet <em>in</em> “/documents”. Even if it did work, it wouldn’t be in a general form.</p>

<p>Let’s call the form we want: <em>“normalization”</em> (this is not a DELPH-IN term, it is being invented here as an concept used for implementation). “Normalizing” a predication will put it into a more general (or canonical) form to reduce whole classes of similar predications (like locative prepositions) into a single form the code can handle the same. Here are a couple of examples to clarify:</p>

<ul>
  <li>Normalizing a locative preposition would put it in into a form that contains the thing being located and the place it is being located to. Note that this is <em>not</em> necessarily just the two arguments of a locative preposition, as is. <code class="language-plaintext highlighter-rouge">_above_p(e17,x8,x18)</code>, for example, would need to record the place (or places) “above” <code class="language-plaintext highlighter-rouge">x18</code> instead of <code class="language-plaintext highlighter-rouge">x18</code> itself.</li>
  <li>Normalizing an adjective like <code class="language-plaintext highlighter-rouge">_green_a_2(e16,x8)</code> might be as simple as recording the adjective and the thing it is applied to, but it won’t always come from predications that are of the form <code class="language-plaintext highlighter-rouge">adjective(e,x)</code>. “paint the tree lit” (for a Christmas tree, perhaps) generates the “adjective” <code class="language-plaintext highlighter-rouge">_light_v_cause(e16,i17,x8)</code> which is a form of verb being <em>used</em> as an adjective.</li>
</ul>

<p>So, we’ll need to implement another version of each predication that knows how to normalize itself. We’ll ask it to put this normalized form into its own introduced event (since it is just information about itself) so that predications like <code class="language-plaintext highlighter-rouge">_copy_v_1</code> can inspect it and decide what to do. And, just like we use the <code class="language-plaintext highlighter-rouge">_comm</code> postfix on predications that implement commands (as opposed to questions), we’ll invent a new postfix called <code class="language-plaintext highlighter-rouge">_norm</code> to indicate that this version of the predication should only be used when it is asked to normalize.  Like this:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>@Predication(vocabulary, names=["_in_p_loc"])
def in_p_loc_norm(state, e_introduced_binding, x_actor_binding, x_location_binding):
    preposition_info = {
        "EndLocation": x_location_binding
    }
    yield state.add_to_e(e_introduced_binding.variable.name, "LocativePreposition", {"Value": preposition_info, "Originator": execution_context().current_predication_index()})
</code></pre></div></div>

<p>In this example, we’ve decided the normalized form of a locative preposition in an event should have the key <code class="language-plaintext highlighter-rouge">LocativePreposition</code> and this JSON value:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>{
    "LeftSide": x_actor_binding,
    "EndLocation": x_location_binding
}
</code></pre></div></div>

<p>… which indicates the “left side” of the locative preposition (i.e. the first, or left argument) and the place where that thing should end up.  Note that this normalized form allows the inspector to ignore what the preposition actually <em>is</em> and just deal with “the place the left side should end up”, thus allowing the copy code to be generalized.</p>

<p>Next, we need a way for <code class="language-plaintext highlighter-rouge">copy_v_1</code> to normalize its scopal argument. We can add a <code class="language-plaintext highlighter-rouge">normalize</code> argument to <code class="language-plaintext highlighter-rouge">ExecutionContext._call_predication()</code> that simply asks to call predications of type “norm” when it is set. That, along with allowing “norm” as a kind of predication in the <code class="language-plaintext highlighter-rouge">Predication</code> decorator, is all that is needed:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>class ExecutionContext(object):
    
    ...
    
    def _call_predication(self, state, predication, normalize=False):
    
    ...
    
            for module_function in self.vocabulary.predications(predication.name,
                                                            predication.arg_types,
                                                            self._phrase_type if normalize is False else "norm"):
    
    ...
</code></pre></div></div>

<p>The next problem is that the scopal argument for <code class="language-plaintext highlighter-rouge">copy_v_1</code> could be a whole tree. For example:</p>

<blockquote>
  <p>copy “blue” in the folder under “/documents”</p>
</blockquote>

<p>… generates a more complicated scopal argument:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>                                                                    ┌── quoted(/documents,i29)
            ┌────── _blue_a_1(x8,i14)                   ┌────── and(0,1)
udef_q(x8,RSTR,BODY)             ┌────── _folder_n_of(x1│,i22)        └ fw_seq(x24,i29)
                 └─ _the_q(x17,RSTR,BODY)               │
                                      └─ proper_q(x24,RSTR,BODY)
                                                             │                 ┌────── pron(x3)                    ┌── _under_p_state(e23,e16,x24)
                                                             └─ pronoun_q(x3,RSTR,BODY)                     ┌─ and(0,1)
                                                                                    └─ _copy_v_1(e2,x3,x8,ARG3)      └ _in_p_loc(e16,x8,x17)
</code></pre></div></div>

<p>So we need a way to somehow figure out which of the predications in the scopal argument introduce the event that holds the “LocativePreposition” value we care about.  Because <code class="language-plaintext highlighter-rouge">_copy_v_1</code> has an argument (<code class="language-plaintext highlighter-rouge">x8</code>) which indicates what it should copy, we can assume any predications in the scopal arg that modify <code class="language-plaintext highlighter-rouge">x8</code> are the ones saying where <code class="language-plaintext highlighter-rouge">x8</code> should go.  We can write a helper that returns those events:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code># Determine which events modify this individual
def scopal_events_modifying_individual(x_individual, h_scopal):
    events = []
    for predication in find_predications_using_variable_ARG1(h_scopal, x_individual):
        if predication.arg_types[0] == "e":
            events.append(predication.args[0])

    return events
</code></pre></div></div>

<p>And now we are finally ready to write the <code class="language-plaintext highlighter-rouge">_copy_v_1</code> verb itself! Be forewarned that there is a lot of “mechanism” to fish the right things out of the right places. We’ll fix that next. But first, let’s see the raw code and understand what it does:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>@Predication(vocabulary, names=["_copy_v_1"])
def locative_copy_v_1_comm(state, e_introduced_binding, x_actor_binding, x_what_binding, h_where):

    # We only know how to copy things from the
    # computer's perspective
    if x_actor_binding.value.name == "Computer":

        # Only allow copying files and folders
        if isinstance(x_what_binding.value, (File, Folder)):
        
            # Determine which events in the scopal argument will hold
            # the LocativePreposition
            where_events = scopal_events_modifying_individual(x_what_binding.variable.name, h_where)
            found_locative_preposition = False
            if len(where_events) &gt; 0:

                # Normalize the tree, which could return multiple solutions like any call()
                for solution in call(state, h_where, normalize=True):
                    
                    # Get the value for each event and see if it holds a 
                    # LocativePreposition
                    for where_event in where_events:
                        e_where_binding = solution.get_binding(where_event)
                        if "LocativePreposition" in e_where_binding.value:
                            
                            # found the information in the event, copy "in" that location
                            found_locative_preposition = True
                            
                            # Only allow copying into folders
                            to_location_binding = e_where_binding.value["LocativePreposition"]["Value"]["EndLocation"]
                            if isinstance(to_location_binding.value, Folder):
                                yield state.apply_operations([CopyOperation(None, x_what_binding, to_location_binding)])

                            else:
                                report_error(["cantDo", "copy", to_location_binding.variable.name])

            if not found_locative_preposition:
                # Fail since we don't know what kind of scopal argument this is
                report_error(["formNotUnderstood", "missing", "LocativePreposition"])

        else:
            report_error(["cantDo", "copy", x_what_binding.variable.name])

    else:
        report_error(["dontKnowActor", x_actor_binding.variable.name])
</code></pre></div></div>

<p>Before we simplify the code, let’s try out some scenarios to make sure it works.  Remember that we have two other interpretations of “copy ‘file1.txt’ in ‘/documents’” that are implemented already. In fact, those two interpretations are returned first by the ERG. So, any phrase that succeeds with one of those won’t exercise this new code.  The phrase “copy ‘blue’ in ‘/documents’” will only work using the latest <code class="language-plaintext highlighter-rouge">copy_v_1</code>, so we’ll use that:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>? what is in '/documents'?
File(name=/documents/file1.txt, size=1000)


? what is in this folder?
File(name=/Desktop/the yearly budget.txt, size=10000000)
File(name=/Desktop/blue, size=1000)


? copy 'blue' in '/documents'
Done!

? /show

...

                          ┌── quoted(blue,i14)
              ┌────── and(0,1)
              │             └ fw_seq(x8,i14)
proper_q(x8,RSTR,BODY)                           ┌── quoted(/documents,i23)
                   │                 ┌────── and(0,1)
                   │                 │             └ fw_seq(x18,i23)
                   └─ proper_q(x18,RSTR,BODY)
                                          │                 ┌────── pron(x3)
                                          └─ pronoun_q(x3,RSTR,BODY)                     ┌─ _in_p_loc(e17,x8,x18)
                                                                 └─ _copy_v_1(e2,x3,x8,ARG3)

...

? what is in '/documents'?
File(name=/documents/file1.txt, size=1000)
File(name=/documents/blue, size=1000)
</code></pre></div></div>

<p>Just to make sure that the expected parse is, in fact, what worked, <code class="language-plaintext highlighter-rouge">/show</code> was executed so we could see the successful tree used and validate it.</p>

<p>Because this code will be the same for all predications that deal with scopal arguments, we can simplify it by writing some helpers.</p>

<h3 id="simplifying-scopal-argument-predications">Simplifying Scopal Argument Predications</h3>
<p>To reduce the amount of ceremony required to deal with a scopal argument, we’ll add the notion of a “virtual argument” to our predications (this is not a DELPH-IN concept, it is just for this Python tutorial). This is a way of declaring what information is needed from an event and having the system pull it out and pass it as an argument instead of fishing it out directly.  It should save a lot of code when dealing with scopal arguments.</p>

<p>In our example, this is the code we are trying to remove:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>def locative_copy_v_1_comm(state, e_introduced_binding, x_actor_binding, x_what_binding, h_where):
   
   ...
   
            # Determine which events in the scopal argument will hold
            # the LocativePreposition
            where_events = scopal_events_modifying_individual(x_what_binding.variable.name, h_where)
            found_locative_preposition = False
            if len(where_events) &gt; 0:
                # Normalize the tree, which could return multiple solutions like any call()
                for solution in call(state, h_where, normalize=True):
                    # Get the value for each event and see if it holds a
                    # LocativePreposition
                    for where_event in where_events:
                        e_where_binding = solution.get_binding(where_event)
                        if "LocativePreposition" in e_where_binding.value:
                            # found the information in the event, copy "in" that location
                            found_locative_preposition = True

                            ...
                            
            if not found_locative_preposition:
                # Fail since we don't know what kind of scopal argument this is
                report_error(["formNotUnderstood", "missing", "LocativePreposition"])
</code></pre></div></div>

<p>To declare that a predication should have a virtual argument added, we’ll add a <code class="language-plaintext highlighter-rouge">virtual_arguments</code> parameter to the <code class="language-plaintext highlighter-rouge">Predication</code> decorator. This will tell the system what information should be found and added as the virtual argument (i.e. one which isn’t normally on this ERG predication).  Below is the same <code class="language-plaintext highlighter-rouge">locative_copy_v_1_comm()</code> function, but now using this new approach. You can see that it adds a new virtual <code class="language-plaintext highlighter-rouge">scopal_argument</code> that is <code class="language-plaintext highlighter-rouge">EventOption.required</code>, and then passes everything the system will need to know to fish out the argument:</p>

<ul>
  <li><code class="language-plaintext highlighter-rouge">scopal_index=3</code>: the <em>index</em> of the scopal argument – i.e. the forth argument passed in (but this is 3 since it is a zero-based index) (<code class="language-plaintext highlighter-rouge">h_where</code>)</li>
  <li><code class="language-plaintext highlighter-rouge">event_for_arg_index=2</code>: the index of the argument that holds the instance we are trying to locate using the locative preposition (<code class="language-plaintext highlighter-rouge">x_what_binding</code>)</li>
  <li><code class="language-plaintext highlighter-rouge">event_value_pattern=locative_preposition_end_location</code>: holds a pattern that can be used to find the value required in an event</li>
</ul>

<p>This is all the information that the above code needed to find and retrieve the locative preposition value. Then, at runtime, if the information is available, it is passed in a new (aka virtual) argument at the end of the predication. This virtual argument is called <code class="language-plaintext highlighter-rouge">where_binding_generator</code> below. Note that this is a <em>generator</em> of values and not a single value since there might be more than one locative preposition found (e.g. “copy ‘foo’ in “\documents” and in “\root”):</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>@Predication(vocabulary, names=["_copy_v_1"], virtual_args=[(scopal_argument(scopal_index=3, event_for_arg_index=2, event_value_pattern=locative_preposition_end_location), EventOption.required)])
def locative_copy_v_1_comm(state, e_introduced_binding, x_actor_binding, x_what_binding, h_where, where_binding_generator):
    # We only know how to copy things from the
    # computer's perspective
    if x_actor_binding.value.name == "Computer":
        # Only allow copying files and folders
        if isinstance(x_what_binding.value, (File, Folder)):
            # We are guaranteed at least one x_where_binding since
            # this is a required virtual_arg
            for x_where_binding in where_binding_generator:
                if isinstance(x_where_binding.value, Folder):
                    yield state.apply_operations([CopyOperation(None, x_what_binding, x_where_binding)])

                else:
                    report_error(["cantDo", "copy", x_where_binding.variable.name])

        else:
            report_error(["cantDo", "copy", x_what_binding.variable.name])

    else:
        report_error(["dontKnowActor", x_actor_binding.variable.name])
</code></pre></div></div>

<p>The last to describe is the <code class="language-plaintext highlighter-rouge">event_value_pattern</code> argument. It is set to a constant declared elsewhere in the file:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code># Constants for creating virtual arguments from scopal arguments
locative_preposition_end_location = {"LocativePreposition": {"Value": {"EndLocation": VariableBinding}}}
</code></pre></div></div>

<p>The virtual argument code needs to be told what value to pull out from the event.  The pattern shown above is a JSON object that “looks” like the part of the event we want to find.  The last value is an actual Python type, and this describes the kind of thing we expect to find. So, the pattern <code class="language-plaintext highlighter-rouge">locative_preposition_end_location</code> above will cause the system to look for:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>event["LocativePreposition"]["Value"]["EndLocation"]
</code></pre></div></div>

<p>… and make sure the value there is a <code class="language-plaintext highlighter-rouge">VariableBinding</code>.</p>

<p>The code below is not important for understanding the semantics of the ERG or DELPH-IN, it is really just to enable the syntactic sugar above.  But here it is for the curious:</p>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code># Return a virtual argument for a predication from a scopal argument
# This will be a generator since there could be more than one found
def scopal_argument(scopal_index, event_for_arg_index, event_value_pattern):
    # Return the actual argument created from the args passed to the predication
    # at runtime and the information originally passed into the scopal_argument function
    def scopal_argument_generator(args):
        # This is the actual generator that loops through the scopal argument
        def possibly_empty_generator():
            # Get the arguments we'll need from the runtime arguments
            x_what_binding = args[event_for_arg_index + 1]
            h_scopal_arg = args[scopal_index + 1]
            state = args[0]

            # Determine which events in the scopal argument we need
            scopal_events = scopal_events_modifying_individual(x_what_binding.variable.name, h_scopal_arg)
            if len(scopal_events) &gt; 0:
                # Normalize the tree, which could return multiple solutions like any call()
                for solution in call(state, h_scopal_arg, normalize=True):
                    # Get the value for each event and see if it holds
                    # the pattern being searched for
                    for scopal_event in scopal_events:
                        found_binding = solution.get_binding(scopal_event)
                        if found_binding.value is not None:
                            found_value = event_value_from_pattern(found_binding.value, event_value_pattern)
                            if found_value is not None:
                                yield found_value

        # Make sure there is at least one value found
        # Otherwise this predication won't be able to execute
        # so an error should be reported
        generator = at_least_one_generator(possibly_empty_generator())
        if generator is None:
            report_error(["formNotUnderstood", "missing",  next(iter(event_value_pattern))])

        else:
            return generator

    return scopal_argument_generator


# Use the pattern in pattern_dict to find a value in event_dict
# The pattern is a nested set of dicts, where the last value is an
# expected type (which could be object if any value is OK):
#
# pattern example: {"LocativePreposition": {"EndLocation": VariableBinding}}
def event_value_from_pattern(event_dict, pattern_dict):
    # Get the first key from pattern_dict
    key = next(iter(pattern_dict))

    if key in event_dict:
        next_event_level = event_dict[key]
        next_pattern_level = pattern_dict[key]
        if isinstance(next_pattern_level, dict):
            return event_value_from_pattern(next_event_level, next_pattern_level)
        elif isinstance(next_event_level, next_pattern_level):
            return next_event_level

    return None


# Determine which events modify this individual
def scopal_events_modifying_individual(x_individual, h_scopal):
    events = []
    for predication in find_predications_using_variable_ARG1(h_scopal, x_individual):
        if predication.arg_types[0] == "e":
            events.append(predication.args[0])

    return events
</code></pre></div></div>

<blockquote>
  <p>Comprehensive source for the completed tutorial is available <a href="https://github.com/EricZinda/Perplexity">here</a>.</p>
</blockquote>

<p>Last update: 2023-05-17 by EricZinda [<a href="https://github.com/EricZinda/Perplexity/edit/main/docs/pxHowTo/pxHowTo095LocativePrepositions.md">edit</a>]</p>

        
      </section>

      <footer class="page__meta">
        
        


        


      </footer>

      

      
    </div>

    
  </article>

  
  
</div>

<!--Scroll the navbar to the current page-->
<script type="text/javascript">
  let el = document.querySelector('.nav__list .active');
  if(el){
    el.scrollIntoView({block: "center", inline: "start"});
  }
</script>
    </div>

    
      <div class="search-content">
        <div class="search-content__inner-wrap"><form class="search-content__form" onkeydown="return event.key != 'Enter';">
    <label class="sr-only" for="search">
      Enter your search term...
    </label>
    <input type="search" id="search" class="search-input" tabindex="-1" placeholder="Enter your search term..." />
  </form>
  <div id="results" class="results"></div></div>

      </div>
    

    <div id="footer" class="page__footer">
      <footer>
        <!-- start custom footer snippets -->

<!-- end custom footer snippets -->
        <div class="page__footer-follow">
  <ul class="social-icons">
    

    
      
        
      
        
      
        
      
        
      
        
      
        
      
    

    
      <li><a href="/Perplexity/home/feed.xml"><i class="fas fa-fw fa-rss-square" aria-hidden="true"></i> Feed</a></li>
    
  </ul>
</div>

<div class="page__footer-copyright">&copy; 2023 Your Name. Powered by <a href="https://jekyllrb.com" rel="nofollow">Jekyll</a> &amp; <a href="https://mademistakes.com/work/minimal-mistakes-jekyll-theme/" rel="nofollow">Minimal Mistakes</a>.</div>

      </footer>
    </div>

    
  <script src="/Perplexity/home/assets/js/main.min.js"></script>




<script src="/Perplexity/home/assets/js/lunr/lunr.min.js"></script>
<script src="/Perplexity/home/assets/js/lunr/lunr-store.js"></script>
<script src="/Perplexity/home/assets/js/lunr/lunr-en.js"></script>







  </body>
</html>
