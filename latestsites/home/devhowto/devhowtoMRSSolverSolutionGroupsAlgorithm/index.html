<!doctype html>
<!--
  Minimal Mistakes Jekyll Theme 4.24.0 by Michael Rose
  Copyright 2013-2020 Michael Rose - mademistakes.com | @mmistakes
  Free for personal and commercial use under the MIT license
  https://github.com/mmistakes/minimal-mistakes/blob/master/LICENSE
-->
<html lang="en" class="no-js">
  <head>
    <meta charset="utf-8">

<!-- begin _includes/seo.html --><title>Perplexity</title>
<meta name="description" content="An amazing website.">


  <meta name="author" content="Your Name">
  


<meta property="og:type" content="website">
<meta property="og:locale" content="en_US">
<meta property="og:site_name" content="Perplexity">
<meta property="og:title" content="Perplexity">
<meta property="og:url" content="http://blog.inductorsoftware.com/Perplexity/home/devhowto/devhowtoMRSSolverSolutionGroupsAlgorithm/">


  <meta property="og:description" content="An amazing website.">











  

  


<link rel="canonical" href="http://blog.inductorsoftware.com/Perplexity/home/devhowto/devhowtoMRSSolverSolutionGroupsAlgorithm/">




<script type="application/ld+json">
  {
    "@context": "https://schema.org",
    
      "@type": "Person",
      "name": "Your Name",
      "url": "http://blog.inductorsoftware.com/Perplexity/home/"
    
  }
</script>







<!-- end _includes/seo.html -->



  <link href="/Perplexity/home/feed.xml" type="application/atom+xml" rel="alternate" title="Perplexity Feed">


<!-- https://t.co/dKP3o1e -->
<meta name="viewport" content="width=device-width, initial-scale=1.0">

<script>
  document.documentElement.className = document.documentElement.className.replace(/\bno-js\b/g, '') + ' js ';
</script>

<!-- For all browsers -->
<link rel="stylesheet" href="/Perplexity/home/assets/css/main.css">
<link rel="preload" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5/css/all.min.css" as="style" onload="this.onload=null;this.rel='stylesheet'">
<noscript><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5/css/all.min.css"></noscript>



    <!-- start custom head snippets -->

<!-- insert favicons. use https://realfavicongenerator.net/ -->

<!-- end custom head snippets -->

  </head>

  <body class="layout--delphin_page wide">
    <nav class="skip-links">
  <ul>
    <li><a href="#site-nav" class="screen-reader-shortcut">Skip to primary navigation</a></li>
    <li><a href="#main" class="screen-reader-shortcut">Skip to content</a></li>
    <li><a href="#footer" class="screen-reader-shortcut">Skip to footer</a></li>
  </ul>
</nav>

    <!--[if lt IE 9]>
<div class="notice--danger align-center" style="margin: 0;">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience.</div>
<![endif]-->

    

<div class="masthead">
  <div class="masthead__inner-wrap">
    <div class="masthead__menu">
      <nav id="site-nav" class="greedy-nav">
        
          <a class="site-logo" href="/Perplexity/home/"><img src="/Perplexity/home/assets/images/Delph-In.png" alt="Perplexity"></a>
        
        <a class="site-title" href="/Perplexity/home/">
          Perplexity
          
        </a>
        <ul class="visible-links"><li class="masthead__menu-item">
              <a href="https://blog.inductorsoftware.com/Perplexity/home/devhowto/devhowtoOverview">Home</a>
            </li></ul>
        
        <button class="search__toggle" type="button">
          <span class="visually-hidden">Toggle search</span>
          <i class="fas fa-search"></i>
        </button>
        
        <button class="greedy-nav__toggle hidden" type="button">
          <span class="visually-hidden">Toggle menu</span>
          <div class="navicon"></div>
        </button>
        <ul class="hidden-links hidden"></ul>
      </nav>
    </div>
  </div>
</div>


    <div class="initial-content">
      





<div id="main" role="main">
  
  <div class="sidebar sticky">
  
  
    
      
      
      
      
    
    
      

<nav class="nav__list">
  
  <input id="ac-toc" name="accordion-toc" type="checkbox" />
  <label for="ac-toc">Toggle Menu</label>
  <ul class="nav__items">
    
      <li>
        
          <span class="nav__sub-title">Background</span>
        

        
        <ul>
          
            <li><a href="/Perplexity/home/devhowto/devhowtoOverview/">Overview</a></li>
          
            <li><a href="/Perplexity/home/devhowto/devhowtoMRS/">Minimal Recursion Semantics (MRS)</a></li>
          
            <li><a href="/Perplexity/home/devhowto/devhowtoWellFormedTree/">Well-Formed Trees</a></li>
          
        </ul>
        
      </li>
    
      <li>
        
          <span class="nav__sub-title">Solving MRS</span>
        

        
        <ul>
          
            <li><a href="/Perplexity/home/devhowto/devhowtoMRSSolver/">Backtracking</a></li>
          
            <li><a href="/Perplexity/home/devhowto/devhowtoMRSSolverSets/">Representing 'Together'</a></li>
          
            <li><a href="/Perplexity/home/devhowto/devhowtoMRSSolverSolutionGroups/">Collective, Distributive, Cumulative</a></li>
          
            <li><a href="/Perplexity/home/devhowto/devhowtoMRSSolverSolutionGroupsAlgorithm/" class="active">Coll/Dist/Cuml Algorithm</a></li>
          
        </ul>
        
      </li>
    
  </ul>
</nav>

    
  
  </div>



  <article class="page h-entry" itemscope itemtype="https://schema.org/CreativeWork">
    
    
    
    

    <div class="page__inner-wrap">
      
        <header>
          


        </header>
      

      <section class="page__content e-content" itemprop="text">
        
        <h2 id="solution-group-algorithm">Solution Group Algorithm</h2>
<p>As described in the <a href="https://blog.inductorsoftware.com/Perplexity/home/devhowto/devhowtoMRSSolverSolutionGroups">previous section</a>, the only way to represent the semantics of cumulative and distributive readings of a sentence like:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>students lifted a table

formula: student(x3), table(x10), lift(x3, x10)
scoped formula: scope(x3, [student(x3), scope(x10, [table(y), lift(x3, x10)])])
</code></pre></div></div>

<p>… is to have the solver create groups of solutions (“solution groups”) that are the “real” answers. This section describes how.</p>

<p>The approach is to generate the solutions exactly like we’ve been doing so far, but then add a new “grouping pass” afterward. This grouping pass will find the groups of solutions that represent actual answers. Solution groups must meet all the <em>numeric constraints</em> that the words in the phrase put on the  variables. For example, for “students lifted a table”:</p>
<ul>
  <li>“students …” is plural, which means the contraint is: <code class="language-plaintext highlighter-rouge">count(students) &gt; 2</code></li>
  <li>“… a table” means the constraint is: <code class="language-plaintext highlighter-rouge">count(tables) = 1</code></li>
  <li>etc.</li>
</ul>

<p>If we simply do the counts across all the solutions in a group and return those where <code class="language-plaintext highlighter-rouge">count(students) &gt; 2</code> and <code class="language-plaintext highlighter-rouge">count(tables) = 1</code>, we will get a bunch of valid groups, but miss all of those that use a “per previous value” interpretation. So, we’ll miss the distributive ones. To get those, we need to do a slightly more complicated counting algorithm that is “per previous value”.</p>

<p>Here’s an overview of the how the algorithm can determine groups that properly account for cumulative, collective and distributive readings:</p>
<blockquote>
  <ol>
    <li>Determine the order variables appear when evaluating the tree</li>
    <li>Walk the variables in order. For each variable: count individuals in the solutions two different ways:
      <ul>
        <li>Cumulatively: Total the variable individuals across all rows (as above)</li>
        <li>Distributive/collectively: Group the individuals by the value of the previous variable in the order, and then do the total <em>per previous value</em>. If the totals are all the same, that is the count. If not, this count fails and has no value.
          <ul>
            <li>If this is the first variable: there is no “previous value” to use in the “total per previous value” definition of collective and distributive. Therefore, the first can only be totalled as cumulative.</li>
          </ul>
        </li>
      </ul>
    </li>
    <li>If either count meets the variable constraint, it succeeds and the next variable in the order is tried. If not, this group fails.</li>
    <li>If the end is reached and all succeeded, this is a valid solution group.</li>
  </ol>
</blockquote>

<p>To get the groups that should be checked, we (you guessed it…) try every combination of solutions that started the process. We will end this entire section with ways of efficiently doing this, but we’ll start with the simplistic approach because it is easier to follow and does work, just not efficiently as it could.</p>

<p>Figuring out the contraints on the variables is a longer story, which the next few sections will cover.</p>

<h3 id="variable-constraints-overview">Variable Constraints Overview</h3>
<p>Notice that every <code class="language-plaintext highlighter-rouge">x</code> variable used in a tree has <em>some kind of</em> numeric constraint applied to it, even if implied. We can model them all using a <code class="language-plaintext highlighter-rouge">between</code> (inclusive) constraint with a lower bound and an upper bound (which could be “inf” meaning “infinity”), like this: <code class="language-plaintext highlighter-rouge">between(min, max)</code>.</p>

<p>For “students lifted a table”:</p>
<ul>
  <li>“students …” is plural, which means: <code class="language-plaintext highlighter-rouge">between(2, inf)</code></li>
  <li>“… a table” means: <code class="language-plaintext highlighter-rouge">between(1, 1)</code> (i.e. exactly 1)</li>
</ul>

<p>For “which file is under 2 tables?”:</p>
<ul>
  <li>“… file …” is singular, which means: <code class="language-plaintext highlighter-rouge">between(1, 1)</code></li>
  <li>“… 2 tables …” specifies two, so: <code class="language-plaintext highlighter-rouge">between(2, 2)</code></li>
</ul>

<p><code class="language-plaintext highlighter-rouge">between(1, inf)</code> is the default constraint meaning: “anything”. Variables with no other constraint get this one, it is implied.</p>

<p>The next section talks about how to extract these constraints from the tree itself.</p>

<h3 id="determining-constraints-from-the-mrs-tree">Determining Constraints From the MRS Tree</h3>
<p>Numeric constraints can come from 3 places in an MRS: Quantifiers, adjectives and the plurality property of a variable. Determining constraints will force us to finally start looking at full MRS documents as opposed to simplified MRS fragments using the made-up <code class="language-plaintext highlighter-rouge">scope()</code> predication. So, let’s start with “two students lifted a table”. Here’s one MRS reading of it, along with one well-formed tree:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>[ "two students lifted a table"
  TOP: h0
  INDEX: e2 [ e SF: prop TENSE: past MOOD: indicative PROG: - PERF: - ]
  RELS: &lt; [ udef_q&lt;0:3&gt; LBL: h4 ARG0: x3 [ x PERS: 3 NUM: pl IND: + ] RSTR: h5 BODY: h6 ]
          [ card&lt;0:3&gt; LBL: h7 ARG0: e9 [ e SF: prop TENSE: untensed MOOD: indicative PROG: - PERF: - ] ARG1: x3 CARG: "2" ]
          [ _student_n_of&lt;4:12&gt; LBL: h7 ARG0: x3 ARG1: i10 ]
          [ _lift_v_cause&lt;13:19&gt; LBL: h1 ARG0: e2 ARG1: x3 ARG2: x11 [ x PERS: 3 NUM: sg IND: + ] ]
          [ _a_q&lt;20:21&gt; LBL: h12 ARG0: x11 RSTR: h13 BODY: h14 ]
          [ _table_n_1&lt;22:27&gt; LBL: h15 ARG0: x11 ] &gt;
  HCONS: &lt; h0 qeq h1 h5 qeq h7 h13 qeq h15 &gt; ]

                        ┌── _student_n_of(x3,i10)
            ┌────── and(0,1)
            │             └ card(2,e9,x3)
udef_q(x3,RSTR,BODY)
                 │             ┌────── _table_n_1(x11)
                 └─ _a_q(x11,RSTR,BODY)
                                    └─ _lift_v_cause(e2,x3,x11)

Text Tree: udef_q(x3,[_student_n_of(x3,i10), card(2,e9,x3)],_a_q(x11,_table_n_1(x11),_lift_v_cause(e2,x3,x11)))
</code></pre></div></div>
<p>Two points to note as we transition to using real MRS instead of simplified trees:</p>

<ol>
  <li>At this point, we can dispense with the artificial <code class="language-plaintext highlighter-rouge">scope()</code> predication we’ve been using  because the <a href="https://blog.inductorsoftware.com/Perplexity/home/devhowto/devhowtoMRS">quantifier predications</a> (those with <code class="language-plaintext highlighter-rouge">_q</code> at the end) in the MRS fulfill the same variable scoping role as <code class="language-plaintext highlighter-rouge">scope()</code>: they declare where in the tree a variable can be used.  They <em>also</em> can add numeric constraints to the variable, as we’ll see below.</li>
  <li>Predications in MRS have <a href="https://blog.inductorsoftware.com/Perplexity/home/devhowto/devhowtoMRS">variable types</a> beyond the <code class="language-plaintext highlighter-rouge">x</code>-type variables we’ve been using. For the examples we’ll see here, these can be safely ignored. We’ll handle those in a later section.</li>
</ol>

<p>With that covered, let’s walk through how to get the numeric constraints from the above MRS.</p>

<h4 id="order-of-variables">Order of Variables</h4>
<p>First, notice that the variable order in this MRS is [<code class="language-plaintext highlighter-rouge">x3</code>, <code class="language-plaintext highlighter-rouge">x11</code>] (read left to right) since that is the order the quantifiers that scope these variables occur in when evaluating the tree.</p>

<h4 id="quantifer-constraints">Quantifer Constraints</h4>
<p>Each variable in an MRS <a href="https://blog.inductorsoftware.com/Perplexity/home/devhowto/devhowtoMRS">must have a quantifier that scopes it</a> (just like we always used a <code class="language-plaintext highlighter-rouge">scope()</code> predication in prior examples), and quantifiers always add a numeric criteria to the variable they scope.  Some, like <code class="language-plaintext highlighter-rouge">udef_q</code> in our example, add the default criteria <code class="language-plaintext highlighter-rouge">between(1, inf)</code> which simply means “at least one”. <code class="language-plaintext highlighter-rouge">_a_q</code> means “a single thing” so it adds <code class="language-plaintext highlighter-rouge">between(1, 1)</code>. Thus, the quantifiers in this example add these constraints:</p>

<table>
  <thead>
    <tr>
      <th><code class="language-plaintext highlighter-rouge">x3</code> (students)</th>
      <th><code class="language-plaintext highlighter-rouge">x11</code>(table)</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">udef</code>: <code class="language-plaintext highlighter-rouge">between(1, inf)</code></td>
      <td><code class="language-plaintext highlighter-rouge">_a_q</code>: <code class="language-plaintext highlighter-rouge">between(1, 1)</code></td>
    </tr>
  </tbody>
</table>

<h4 id="adjective-constraints">Adjective Constraints</h4>
<p>Some adjectives also add numeric constraints. In our example, the adjective “two” gets converted to <code class="language-plaintext highlighter-rouge">card(2,e9,x3)</code> in the MRS. This predication adds the constraint <code class="language-plaintext highlighter-rouge">between(2, 2)</code> to <code class="language-plaintext highlighter-rouge">x3</code>. Now we have these:</p>

<table>
  <thead>
    <tr>
      <th><code class="language-plaintext highlighter-rouge">x3</code> (students)</th>
      <th><code class="language-plaintext highlighter-rouge">x11</code>(table)</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">udef</code>: <code class="language-plaintext highlighter-rouge">between(1, inf)</code></td>
      <td><code class="language-plaintext highlighter-rouge">_a_q</code>: <code class="language-plaintext highlighter-rouge">between(1, 1)</code></td>
    </tr>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">card</code>: <code class="language-plaintext highlighter-rouge">between(2, 2)</code></td>
      <td> </td>
    </tr>
  </tbody>
</table>

<h4 id="plural-variable-properties">Plural Variable Properties</h4>
<p>Finally, some variables (<code class="language-plaintext highlighter-rouge">x3</code> in our example), are defined to be plural by the MRS, as indicated by <code class="language-plaintext highlighter-rouge">NUM: pl</code> in the <a href="https://blog.inductorsoftware.com/Perplexity/home/devhowto/devhowtoMRS">variable properties</a> of <code class="language-plaintext highlighter-rouge">x3</code>:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>[ udef_q&lt;0:3&gt; LBL: h4 ARG0: x3 [ x PERS: 3 NUM: pl IND: + ] RSTR: h5 BODY: h6 ]
</code></pre></div></div>

<p>This adds the constraint <code class="language-plaintext highlighter-rouge">between(2, inf)</code> to <code class="language-plaintext highlighter-rouge">x3</code>.</p>

<p><code class="language-plaintext highlighter-rouge">x11</code> from <code class="language-plaintext highlighter-rouge">_table_n_1(x11)</code> is singular from its variable properties:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>[ _lift_v_cause&lt;13:19&gt; LBL: h1 ARG0: e2 ARG1: x3 ARG2: x11 [ x PERS: 3 NUM: sg IND: + ] ]
</code></pre></div></div>

<p>…  so it gets <code class="language-plaintext highlighter-rouge">between(1, 1)</code>:</p>

<p>Thus, our final list of constraints is:
|<code class="language-plaintext highlighter-rouge">x3</code> (students)|<code class="language-plaintext highlighter-rouge">x11</code>(table)|
|—|—|
|<code class="language-plaintext highlighter-rouge">udef</code>: <code class="language-plaintext highlighter-rouge">between(1, inf)</code>| <code class="language-plaintext highlighter-rouge">_a_q</code>: <code class="language-plaintext highlighter-rouge">between(1, 1)</code>|
|<code class="language-plaintext highlighter-rouge">card</code>: <code class="language-plaintext highlighter-rouge">between(2, 2)</code>| <code class="language-plaintext highlighter-rouge">[NUM: sg]</code>: <code class="language-plaintext highlighter-rouge">between(1, 1)</code> |
|<code class="language-plaintext highlighter-rouge">[NUM: pl]</code>: <code class="language-plaintext highlighter-rouge">between(2, inf)</code>| |</p>

<h4 id="combining-constraints">Combining Constraints</h4>
<p>The final constraints from the example can be combined.  If <code class="language-plaintext highlighter-rouge">x3</code> must be:</p>
<ul>
  <li>“between 1 and infinity” <em>and</em> “between 2 and infinity” then saying “between 2 and infinity” is enough.</li>
  <li>“between 2 and infinity” <em>and</em> “between 2 and 2 (i.e. exactly 2)” then saying “between 2 and 2” is enough.</li>
</ul>

<p>Using this logic, the final list of constraints above can be reduced to:
|<code class="language-plaintext highlighter-rouge">x3</code> (students)|<code class="language-plaintext highlighter-rouge">x11</code>(table)|
|—|—|
|<code class="language-plaintext highlighter-rouge">between(2, 2)</code>| <code class="language-plaintext highlighter-rouge">between(1, 1)</code>|</p>

<p>Which matches the intuition you’d have that there should be exactly two students and exacty one table (possibly for each student) in “two students lifted a table”.</p>

<h4 id="mrs-constraints-summary">MRS Constraints Summary</h4>
<p>So, now we have an approach to gathering the constraints from the MRS:</p>

<blockquote>
  <p>For each <code class="language-plaintext highlighter-rouge">x</code> variable in the MRS:</p>
  <ol>
    <li>Add the appropriate constraint for its quantifier</li>
    <li>Add any constraints from adjectives that modify it</li>
    <li>Add the <code class="language-plaintext highlighter-rouge">NUM: pl</code> or <code class="language-plaintext highlighter-rouge">NUM: sg</code> constraint</li>
    <li>Reduce them to the minimal set</li>
  </ol>
</blockquote>

<h3 id="the-final-algorithm-introducing-phase-0">The Final Algorithm: Introducing Phase 0</h3>
<p>This section started by describing the solver algorithm as having two phases:</p>
<ul>
  <li>Phase 1: Evaluate the MRS to get the solutions</li>
  <li>Phase 2: Group the solutions into solution groups that meet the numeric criteria</li>
</ul>

<p>Turns out that the (just described) process of building the numeric criteria is really a “Phase 0”. And, if you think about what adjectives like “two” (or “a few” or “many”) actually <em>do</em>, their entire contribution happens during Phase 2 … they have nothing to do in Phase 1. So, after we extract the criteria from them in Phase 0, they should be <em>removed from the tree</em> and Phase 1 should be solved using the modified tree.</p>

<p>Furthermore, recall that quantifiers do two things: scope a variable and add numeric criteria to the variable. So, after you extract the numeric contribution of quantifiers like <code class="language-plaintext highlighter-rouge">_a_q</code> or <code class="language-plaintext highlighter-rouge">_some_q</code>, you’ve also removed all of their contribution to Phase 1 <em>except for variable scoping</em>. So, we don’t <em>remove</em> them, but we do <em>replace</em> them with the most generic quantifier: <code class="language-plaintext highlighter-rouge">udef_q</code>.</p>

<p>Thus, Phase 0 analyzes the full tree for “2 students lifted a table”, which is this:</p>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>                        ┌── _student_n_of(x3,i10)
            ┌────── and(0,1)
            │             └ card(2,e9,x3)
udef_q(x3,RSTR,BODY)
                 │             ┌────── _table_n_1(x11)
                 └─ _a_q(x11,RSTR,BODY)
                                    └─ _lift_v_cause(e2,x3,x11)
</code></pre></div></div>
<p>… but then, after extracting numeric constraints, converts it to a tree without the numeric constraints it it (since those will run in Phase 2), and provides this modified tree to Phase 1:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>            ┌────── _student_n_of(x3,i10)
            │             
udef_q(x3,RSTR,BODY)
                 │               ┌────── _table_n_1(x11)
                 └─ udef_q(x11,RSTR,BODY)
                                      └─ _lift_v_cause(e2,x3,x11)
</code></pre></div></div>

<p>… and finally Phase 3 runs the extracted numeric constraints over the Phase 1 solutions to generate the final solution groups.</p>

<p>Here’s the full algorithm all in one place:</p>

<blockquote>
  <p>Phase 0: Setup</p>
  <ol>
    <li>Start with a well-formed MRS Tree</li>
    <li>Determine the list of <code class="language-plaintext highlighter-rouge">x</code> variables in the tree and the order they will be evaluated in</li>
    <li>Determine the constraints placed on each <code class="language-plaintext highlighter-rouge">x</code> variable by predications that modify it.</li>
    <li>Create a modified tree by:
      <ul>
        <li>Removing adjective predications that added numeric constraints</li>
        <li>Changing quantifiers that added numeric constraints to <code class="language-plaintext highlighter-rouge">udef_q</code></li>
      </ul>
    </li>
  </ol>

  <p>Phase 1: Solution Generation</p>

  <ol>
    <li>Generate the list of solutions to the modified tree using the approach described in the <a href="https://blog.inductorsoftware.com/Perplexity/home/devhowto/devhowtoMRSSolverSets">previous section</a></li>
  </ol>

  <p>Phase 2: Group Generation</p>

  <ol>
    <li>For each possible combination of solutions from Phase 1: Walk the <code class="language-plaintext highlighter-rouge">x</code> variables in evaluation order.</li>
    <li>For each <code class="language-plaintext highlighter-rouge">x</code> variable: Count individuals in the solutions two different ways:
      <ul>
        <li>Cumulatively: Total the variable individuals across all solutions</li>
        <li>Distributive/collectively: Group the individuals by the value of the previous variable in the order, and total individuals in this variable per previous value. If the totals are all the same, that is the count. If not, this count fails and has no value.
          <ul>
            <li>If this is the first variable, there is no “previous value” to use in the “total per previous value” definition of distributive/collective. Therefore, the first can only be totalled cumulatively</li>
          </ul>
        </li>
      </ul>
    </li>
    <li>If either count meets the variable constraints: it succeeds and the next variable in the order is tried
      <ul>
        <li>If not: this group fails and the next group starts at step #5</li>
      </ul>
    </li>
    <li>If the end of the variables is reached and all succeeded, this is a valid solution group</li>
  </ol>
</blockquote>

<h3 id="example">Example</h3>
<p>That can be a lot to take in, so let’s go through an example: “students lifted a table”:</p>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>[ "students lifted a table"
  TOP: h0
  INDEX: e2 [ e SF: prop TENSE: past MOOD: indicative PROG: - PERF: - ]
  RELS: &lt; [ udef_q&lt;0:8&gt; LBL: h4 ARG0: x3 [ x PERS: 3 NUM: pl IND: + ] RSTR: h5 BODY: h6 ]
          [ _student_n_of&lt;0:8&gt; LBL: h7 ARG0: x3 ARG1: i8 ]
          [ _lift_v_cause&lt;9:15&gt; LBL: h1 ARG0: e2 ARG1: x3 ARG2: x9 [ x PERS: 3 NUM: sg IND: + ] ]
          [ _a_q&lt;16:17&gt; LBL: h10 ARG0: x9 RSTR: h11 BODY: h12 ]
          [ _table_n_1&lt;18:23&gt; LBL: h13 ARG0: x9 ] &gt;
  HCONS: &lt; h0 qeq h1 h5 qeq h7 h11 qeq h13 &gt; ]

            ┌────── _student_n_of(x3,i8)
udef_q(x3,RSTR,BODY)          ┌────── _table_n_1(x10)
                 └─ _a_q(x10,RSTR,BODY)
                                   └─ _lift_v_cause(e2,x3,x10)

Text Tree: udef_q(x3,_student_n_of(x3,i8),_a_q(x10,_table_n_1(x10),_lift_v_cause(e2,x3,x10)))
</code></pre></div></div>

<h4 id="phase-0-setup">Phase 0: Setup</h4>
<blockquote>
  <ol>
    <li>Start with a well-formed MRS Tree</li>
    <li>Determine the list of <code class="language-plaintext highlighter-rouge">x</code> variables in the tree and the order they will be evaluated in</li>
    <li>Determine the constraints placed on each <code class="language-plaintext highlighter-rouge">x</code> variable by predications that modify it.</li>
  </ol>
</blockquote>

<p>Using the approach described above, the evaluation order of variables is [<code class="language-plaintext highlighter-rouge">x3</code>, <code class="language-plaintext highlighter-rouge">x10</code>] and the found constraints for the variables are:</p>

<table>
  <thead>
    <tr>
      <th><code class="language-plaintext highlighter-rouge">x3</code> (students)</th>
      <th><code class="language-plaintext highlighter-rouge">x10</code>(table)</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">udef</code>: <code class="language-plaintext highlighter-rouge">between(1, inf)</code></td>
      <td><code class="language-plaintext highlighter-rouge">_a_q</code>: <code class="language-plaintext highlighter-rouge">between(1, 1)</code></td>
    </tr>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">[NUM: pl]</code>: <code class="language-plaintext highlighter-rouge">between(2, inf)</code></td>
      <td><code class="language-plaintext highlighter-rouge">[NUM: sg]</code>: <code class="language-plaintext highlighter-rouge">between(1, 1)</code></td>
    </tr>
  </tbody>
</table>

<p>When simplified, they are:
|<code class="language-plaintext highlighter-rouge">x3</code> (students)|<code class="language-plaintext highlighter-rouge">x10</code>(table)|
|—|—|
|<code class="language-plaintext highlighter-rouge">between(2, inf)</code>| <code class="language-plaintext highlighter-rouge">between(1, 1)</code> |</p>

<blockquote>
  <ol>
    <li>Create a modified tree by:
      <ul>
        <li>Removing adjective predications that added numeric constraints</li>
        <li>Changing quantifiers that added numeric constraints to <code class="language-plaintext highlighter-rouge">udef_q</code></li>
      </ul>
    </li>
  </ol>
</blockquote>

<p>The modified tree is:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>            ┌────── _student_n_of(x3,i8)
udef_q(x3,RSTR,BODY)             ┌────── _table_n_1(x10)
                 └─ udef_q(x10,RSTR,BODY)
                                      └─ _lift_v_cause(e2,x3,x10)
</code></pre></div></div>

<h4 id="phase-1-solution-generation">Phase 1: Solution Generation</h4>

<blockquote>
  <ol>
    <li>Generate the list of solutions to the modified tree using the approach described in the <a href="https://blog.inductorsoftware.com/Perplexity/home/devhowto/devhowtoMRSSolverSets">previous section</a></li>
  </ol>
</blockquote>

<p>Using a (unshown) world state, and using the approach described in the <a href="https://blog.inductorsoftware.com/Perplexity/home/devhowto/devhowtoMRSSolverSets">previous section</a>, the solutions to the modified tree are:</p>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>"students lifted a table"

Tree: udef_q(x3,_student_n_of(x3,i8),udef_q(x10,_table_n_1(x10),_lift_v_cause(e2,x3,x10)))

Solution 1: x3=[student1], x10=[table1]                     "student1 is lifting table1"
Solution 2: x3=[student2], x10=[table2]
Solution 3: x3=[student3], x10=[table3]
Solution 4: x3=[student3], x10=[table4]
Solution 5: x3=[student4], x10=[table5]
Solution 6: x3=[student4], x10=[table6]
Solution 7: x3=[student5,student6], x10=[table7]            "student5 and student6 [together] are lifting table7"
Solution 8: x3=[student5,student6], x10=[table8]
Solution 9: x3=[student7,student8], x10=[table9, table10]   "student7 and student8 [together] are lifting table9 and table10 [at the same time]"
Solution 10: x3=[student9], x10=[table11, table12]          "student9 is lifting table11 and table12 [at the same time]"
Solution 11: x3=[student10,student11], x10=[table13]
Solution 12: x3=[student12], x10=[table14]
</code></pre></div></div>

<h4 id="phase-2-group-generation">Phase 2: Group Generation</h4>
<blockquote>
  <ol>
    <li>For each possible combination of solutions from Phase 1: Walk the <code class="language-plaintext highlighter-rouge">x</code> variables in evaluation order.</li>
  </ol>
</blockquote>

<p>Start by generating groups that are all combinations of the above solutions, like this partial list:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Group 1:
  Solution 1: x3=[student1], x10=[table1]                     "student1 is lifting table1"

Group 2:
  Solution 1: x3=[student1], x10=[table1]                     "student1 is lifting table1"
  Solution 2: x3=[student2], x10=[table2]

Group 3:
  Solution 1: x3=[student1], x10=[table1]                     "student1 is lifting table1"
  Solution 2: x3=[student2], x10=[table2]
  Solution 3: x3=[student3], x10=[table3]

... etc. (there are *many* more groups not listed)
</code></pre></div></div>

<blockquote>
  <ol>
    <li>For each <code class="language-plaintext highlighter-rouge">x</code> variable: Count individuals in the solutions two different ways:
      <ul>
        <li>Cumulatively: Total the variable individuals across all solutions</li>
        <li>Distributive/collectively: Group the individuals by the value of the previous variable in the order, and total individuals in this variable per previous value. If the values are all the same, that is the count. If not, this count fails and has no value.
          <ul>
            <li>If this is the first variable, there is no “previous value” to use in the “total per previous value” definition of distributive/collective. Therefore, the first can only be totalled cumulatively</li>
          </ul>
        </li>
      </ul>
    </li>
    <li>If either count meets the variable constraints: it succeeds and the next variable in the order is tried
      <ul>
        <li>If not: this group fails and the next group starts at step #5</li>
      </ul>
    </li>
    <li>If the end of the variables is reached and all succeeded, this is a valid solution group</li>
  </ol>
</blockquote>

<p>Using the constraints we determined:
|<code class="language-plaintext highlighter-rouge">x3</code> (students)|<code class="language-plaintext highlighter-rouge">x10</code>(table)|
|—|—|
|<code class="language-plaintext highlighter-rouge">between(2, inf)</code>| <code class="language-plaintext highlighter-rouge">between(1, 1)</code> |</p>

<p>… let’s analyze each group:</p>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Group 1:
  Solution 1: x3=[student1], x10=[table1]                     "student1 is lifting table1"
</code></pre></div></div>

<p><code class="language-plaintext highlighter-rouge">x3</code> is the first variable so we only do the cumulative count for it: <code class="language-plaintext highlighter-rouge">cumulative_count=1</code>. The constraint on <code class="language-plaintext highlighter-rouge">x3</code> is <code class="language-plaintext highlighter-rouge">between(2, inf)</code>. Thus: this group fails.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Group 2:
  Solution 1: x3=[student1], x10=[table1]                     "student1 is lifting table1"
  Solution 2: x3=[student2], x10=[table2]
</code></pre></div></div>
<p><code class="language-plaintext highlighter-rouge">x3</code> is the first variable so we only do the cumulative count for it: <code class="language-plaintext highlighter-rouge">cumulative_count=2</code> which passes the constraint <code class="language-plaintext highlighter-rouge">between(2, inf)</code>. Try the next variable.</p>

<p><code class="language-plaintext highlighter-rouge">x10</code> gets both kinds of count:</p>
<ul>
  <li><code class="language-plaintext highlighter-rouge">cumulative_count=2</code></li>
  <li><code class="language-plaintext highlighter-rouge">dist_coll_count(student1)=1</code>, <code class="language-plaintext highlighter-rouge">dist_coll_count(student2)=1</code>. Both counts are the same so <code class="language-plaintext highlighter-rouge">dist_coll_count=1</code> The constraint on <code class="language-plaintext highlighter-rouge">x10</code> is <code class="language-plaintext highlighter-rouge">between(1, 1)</code>. Thus: this variable succeeds.</li>
</ul>

<p>There are no more variables, thus this group is an answer: a <em>distributive</em> answer.</p>

<p>etc.</p>

<p>All of the groups that succeed will be valid collective, distributive or cumulative readings of the phrase in that world.</p>

<p>There are a couple of subtleties that need to be address with this algorithm. Namely the special handling of “which” and “the”. That is described in the next section.</p>

<p>Last update: 2023-04-27 by EricZinda [<a href="https://github.com/EricZinda/Perplexity/edit/main/docs/devhowto/devhowtoMRSSolverSolutionGroupsAlgorithm.md">edit</a>]</p>

        
      </section>

      <footer class="page__meta">
        
        


        


      </footer>

      

      
    </div>

    
  </article>

  
  
</div>

<!--Scroll the navbar to the current page-->
<script type="text/javascript">
  let el = document.querySelector('.nav__list .active');
  if(el){
    el.scrollIntoView({block: "center", inline: "start"});
  }
</script>
    </div>

    
      <div class="search-content">
        <div class="search-content__inner-wrap"><form class="search-content__form" onkeydown="return event.key != 'Enter';">
    <label class="sr-only" for="search">
      Enter your search term...
    </label>
    <input type="search" id="search" class="search-input" tabindex="-1" placeholder="Enter your search term..." />
  </form>
  <div id="results" class="results"></div></div>

      </div>
    

    <div id="footer" class="page__footer">
      <footer>
        <!-- start custom footer snippets -->

<!-- end custom footer snippets -->
        <div class="page__footer-follow">
  <ul class="social-icons">
    

    
      
        
      
        
      
        
      
        
      
        
      
        
      
    

    
      <li><a href="/Perplexity/home/feed.xml"><i class="fas fa-fw fa-rss-square" aria-hidden="true"></i> Feed</a></li>
    
  </ul>
</div>

<div class="page__footer-copyright">&copy; 2023 Your Name. Powered by <a href="https://jekyllrb.com" rel="nofollow">Jekyll</a> &amp; <a href="https://mademistakes.com/work/minimal-mistakes-jekyll-theme/" rel="nofollow">Minimal Mistakes</a>.</div>

      </footer>
    </div>

    
  <script src="/Perplexity/home/assets/js/main.min.js"></script>




<script src="/Perplexity/home/assets/js/lunr/lunr.min.js"></script>
<script src="/Perplexity/home/assets/js/lunr/lunr-store.js"></script>
<script src="/Perplexity/home/assets/js/lunr/lunr-en.js"></script>







  </body>
</html>
