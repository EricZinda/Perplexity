### Improving Quantifier Errors
With the same approach to error reporting in `_file_n_of` that we did in `large_a_1`:
~~~
@Predication(vocabulary, name="_file_n_of")
def file_n_of(state, x):
    
    ...
    
    for item in iterator:
        if isinstance(item, File):
            new_state = state.SetX(x, item)
            yield new_state
        else:
            ReportError(["xIsNotY", x, "file"])
~~~

... and evaluating "A file is large":

~~~
          ┌────── _file_n_of(x3,i8)
_a_q(x3,RSTR,BODY)    
               └─ _large_a_1(e2,x3)
~~~

... against a world of *no* files:

~~~
a dog
a folder
~~~

We got the response, "A thing is not a file", which is a little *too* obtuse. Yes, maybe, the user *might* interpret that as "Nothing is a file" (which would be a fine error), but we can generate something better.

To understand how, we need to look at how the MRS is evaluated. Every variable in an MRS is "scoped" by exactly one quantifier -- the quantifier that has the variable as its first argument. "Scoped" means that the only things that can reference that variable must be in the branches of the `RSTR` or `BODY` of that quantifier and nowhere else in the MRS.  The quantifier works like this:

- The `RSTR` scopal argument defines what is being quantified
- The quantifier itself specifies "how much" of the `RSTR` is being selected
- The `BODY` defines what is happening to the quantified items from the `RSTR`

For example, "A file is large" has the `_a_q` quantifier:
~~~
          ┌────── _file_n_of(x3,i8)
_a_q(x3,RSTR,BODY)    
               └─ _large_a_1(e2,x3)
~~~
... and this means: `_a_q` is true when "an arbitrary single item" (the quantification "a") from the `RSTR` (`_file_n_of(x3,i8)`) is true when the `BODY` (`_large_a_1(e2,x3)`) is evaluated. 

So, it turns out that the error we want to generate, "There aren't any files", could be generated by the *quantifier* if there is nothing in the `RSTR` to try on the `BODY`. 

Said differently, quantifiers should always report an error like "There aren't any 'whatever the `RSTR` said'" if there aren't any solutions to the `RSTR`. *That* is how we get the right error for this scenario.

Because our error system will always report the *deepest* error, and the error that comes from the `RSTR` will be deeper than the error from its quantifier, we'll need to add a way to "force" an error in our `ReportError()` method, like this:

~~~
    def ReportError(self, error, force=False):
        if force or self._error_predication_index < self._predication_index:
            self._error = error
            self._error_predication_index = self._predication_index
~~~

Then, we can modify the implementation of `a_q` to report a better error when the `RSTR` can't be solved:

~~~
@Predication(vocabulary, name="_a_q")
def a_q(state, x_variable, h_rstr, h_body):
    # Run the RSTR which should fill in the variable with an item
    rstr_found = False
    for solution in Call(vocabulary, state, h_rstr):
        rstr_found = True

        # Now see if that solution works in the BODY
        body_found = False
        for body_solution in Call(vocabulary, solution, h_body):
            yield body_solution
            body_found = True

        if body_found:
            # If it works, stop looking. This one is the single arbitrary item we are looking for
            break

    if not rstr_found:
        # Ignore whatever error the RSTR produced, this is a better one
        ReportError(["doesntExist", x_variable], force=True)
        
       
def GenerateMessage(mrs, error_term):

    ...
    
    if error_constant == "doesntExist":
        arg1 = EnglishForDelphinVariable(error_constant, error_arguments[1], mrs)
        return f"There isn't {arg1} in the system"
        
    ...
    
# Evaluate the proposition: "a file is large" when there are no files, period
def Example11():
    state = State([Folder(name="Desktop"),
                   Folder(name="Documents")])

    mrs = {}
    mrs["Index"] = "e1"
    mrs["Variables"] = {"x1": {"NUM": "pl"},
                        "e1": {"SF": "prop"}}
    mrs["RELS"] = [["_a_q", "x1", ["_file_n_of", "x1"], ["_large_a_1", "e1", "x1"]]]

    state = state.SetX("mrs", mrs)
    DelphinContext().RespondToMRS(state, mrs)
    
# Prints:
There isn't a thing in the system
~~~
This is close, but it is saying "thing" instead of "file". Recall that `EnglishForDelphinVariable()` converts variables to their English equivalents *at the point where the error happened*. Since `a_q` is reporting the error, the function thinks neither the `RSTR` or `BODY` has been evaluated yet. Thus `x` is only a "thing" at that point. We need a way for `a_q` to indicate that it wants what `x` will contain *after the `RSTR` is evaluated*.

We'll do this by creating a function `IndexOfPredication()` that gives the index of any predication in an MRS. Then, instead of passing the variable itself in the error (`x1`), we'll pass a special list that will tell `EnglishForDelphinVariable()` to use the variables value "as if it was evaluated at a different predication" like this:

~~~
ReportError(["doesntExist", ["AtPredication", h_body, x_variable]], force=True)
~~~

Here's the code that does it all:

~~~
# Returns the index of a predication in an MRS
def IndexOfPredication(mrs, stop_predication):
    current_predication_index = [1]

    def StopAtBranch(predication):
        if predication == stop_predication:
            # This is the predication we are looking for
            # Return the index of it
            return current_predication_index[0]
        else:
            current_predication_index[0] = current_predication_index[0] + 1

    return WalkTreeUntil(mrs["RELS"], StopAtBranch)
    
    
def EnglishForDelphinVariable(failure_index, variable, mrs):
    if isinstance(variable, list):
        if variable[0] == "AtPredication":
            failure_index = IndexOfPredication(mrs, variable[1])
            variable = variable[2]
            
    ...
    
    
@Predication(vocabulary, name="_a_q")
def a_q(state, x_variable, h_rstr, h_body):
    
    ...
    
    if not rstr_found:
        # Ignore whatever error the RSTR produced, this is a better one
        # Report the variable's English representation as it would be in the BODY
        ReportError(["doesntExist", ["AtPredication", h_body, x_variable]], force=True)
~~~

Now when we say "A file is large" in a world with no files we get "There isn't a file in the system". Much better!

