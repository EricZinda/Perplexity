# Overview
Perplexity is a Python framework for building natural language interfaces to software. It does deep linguistic processing by using the [DELPH-IN](https://delph-in.github.io/docs/home/Home/) technologies which take a very different approach from that used in Large Language Models. To use Perplexity, you implement a set of logic-based functions that represent the words in your domain using Python. Thus, it is truly "hallucination-free" because is it uses only code that you have written, that can be inspected, debugged, etc. There is no "magic" going on. You can always understand exactly why a phrase was understood the way it was because you can debug it using regular tools, applied to regular Python code. The cost for this approach is that you actually need to implement the logic for all the words in your domain. This documentation will show you how.

The DELPH-IN technologies are the basis for the deep linguistic processing in Perplexity, but they stop at generating a logical representation of a phrase. 
This tutorial is designed to show *developers* how to consume this logical representation using a narrow set of DELPH-IN technologies (especially [MRS](mrscon/devhowto0010MRS) and [ACE](http://sweaglesw.org/linguistics/ace/)) to build an application. It focuses on *one particular* application (a natural language interface to a computer's file system), but the concepts should apply to any type of constrained system ('constrained' in the sense of the size of the world under discussion). It also takes *one particular approach* to building the system by logically evaluating the output of the DELPH-IN parsers against a world definition. While this approach may not be the right one for every application, the concepts illustrated and the tools used along the way should be more broadly applicable.

The tutorial will use the [DELPH-IN English Resource Grammar (ERG)](https://delph-in.github.io/docs/erg/ErgTop/) to parse English, but the concepts are the same across the [DELPH-IN grammars](https://delph-in.github.io/docs/grammars/GrammarsOverview/).  In fact, the library functions we build have no dependency on the grammar at all. They can be used for any of the DELPH-IN grammars.

Python was chosen as a simple, popular, open-source language available on many platforms. However, the examples and approach shown here could be implemented in any language. There is not much code in the core solver and associated helper functions that would need to be translated. The overwhelming majority of code will be in the implementation of the terms you implement for your own domain.

It is designed to be read in order, but the most important background is in the first two sections, [The Minimal Recursion Semantics (MRS) Format](mrscon/devhowto0010MRS) and [Building Well-Formed MRS Trees](mrscon/devhowto0020WellFormedTree). These should definitely be read before moving on to the rest of the topics. The rest of the topics broadly break down into [*how-to topics*](pxHowTo/pxHowTo010Overview) which walk through writing the Python code to implement a system and [*conceptual topics*](devcon/devcon0000Overview) which cover the background on the algorithms and concepts referred to in the How-To.

> Comprehensive source for the completed tutorial is available [here](https://github.com/EricZinda/Perplexity/samples/hello_world).