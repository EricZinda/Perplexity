# Overview

The DELPH-IN Consortium has developed a large and rich set of technologies for manipulating natural language. The list of [DELPH-IN applications](https://delph-in.github.io/docs/home/DelphinApplications/) is a great place to start for a survey of different approaches to using them and the [DELPH-IN How-To section](https://delph-in.github.io/docs/howto/DelphinWelcome/) is a good starting point for understanding the technology.

This tutorial is designed to show *developers* how to consume a narrow set of DELPH-IN technologies (especially [MRS](mrscon/devhowto0010MRS) and [ACE](http://sweaglesw.org/linguistics/ace/)) to build an application. It focuses on *one particular* application (a natural language interface to a computer's file system), but the concepts should apply to any type of constrained system ('constrained' in the sense of the size of the world under discussion). It also takes *one particular approach* to building the system by logically evaluating the output of the DELPH-IN parsers against a world definition. While this approach may not be the right one for every application, the concepts illustrated and the tools used along the way should be more broadly applicable.

The tutorial will use the [DELPH-IN English Resource Grammar (ERG)](https://delph-in.github.io/docs/erg/ErgTop/) to parse English, but the concepts are the same across the [DELPH-IN grammars](https://delph-in.github.io/docs/grammars/GrammarsOverview/).  In fact, the library functions we build have no dependency on the grammar at all. They can be used for any of the DELPH-IN grammars.

Python was chosen as a simple, popular, open-source language available on many platforms. However, the examples and approach shown here could be implemented in any language. There is not much code in the core solver and associated helper functions that would need to be translated. The overwhelming majority of code will be in the implementation of the terms you implement for your own domain.

It is designed to be read in order, but the most important background is in the first two sections, [The Minimal Recursion Semantics (MRS) Format](mrscon/devhowto0010MRS) and [Building Well-Formed MRS Trees](mrscon/devhowto0020WellFormedTree). These should definitely be read before moving on to the rest of the topics. The rest of the topics broadly break down into [*how-to topics*](pxHowTo/pxHowTo010Overview) which walk through writing the Python code to implement a system and [*conceptual topics*](devcon/devcon0000Overview) which cover the background on the algorithms and concepts referred to in the How-To.

> Comprehensive source for the completed tutorial is available [here](https://github.com/EricZinda/Perplexity).