### Assumptions
Nouns are defined as types and instances.  Once defined, the types are returned as concepts (i.e. Concept()) and the instances are returned as strings.

If a noun like "order" is encountered (as in "what is my order?") the solver will first push the concept of "order" (i.e. Concept("order")) through the system, then all of the instances.  If there are predications that are "lift style", the instances will also come through in all combinations meaning "together".  The solution groups generated by the concepts phase and the instances phase are kept distinct.


### "What dishes do you have?" -- least general
Let's imagine we want to write the implementation for "What dishes do you have?", interpreting it as meaning "what is on the menu?".  The least general way to approach the implementation is to write code that literally recognizes the phrase "What dishes do you have?" and prints out the answer.  This would be a fine approach for phrases that either don't have a strictly logical interpretation, or the strictly logical interpretation won't be right (or enough).  For example, a phrase like "Could I have the chicken?", logically would invite the response "Yes!", but is really a request to order it. 

Here is the tree we will be working with:
~~~
_which_q(x5,_dish_n_of(x5,i9),pronoun_q(x3,pron(x3),_have_v_1(e2,x3,x5)))
~~~

... and if we get rid of the quantifiers, these are the predications we'll have to deal with:

~~~
_dish_n_of(x5,i9), pron(x3), _have_v_1(e2,x3,x5)
~~~

~~~
@Predication(vocabulary,
             names=["_have_v_1"],
             phrases={
                "What do you have?": {'SF': 'ques', 'TENSE': 'pres', 'MOOD': 'indicative', 'PROG': '-', 'PERF': '-'}
             },
             properties={'SF': 'ques', 'TENSE': 'pres', 'MOOD': 'indicative', 'PROG': '-', 'PERF': '-'})
def _have_v_1(context, state, e_introduced_binding, x_actor_binding, x_object_binding):
    def bound(x_actor, x_object):
        if x_actor != "restaurant":
            # If the user is asking about "what does he/she/I have", etc.
            # Just say we don't know
            context.report_error(["errorText", "I don't know"])
            return

        if is_concept(x_object):
            if x_object.concept_name == "dish" and x_object.find_criteria(None, None, None) is None:
                return True

    def actor_from_object(x_object):
        # Just fail for now
        if False:
            yield None

    def object_from_actor(x_actor):
        # Just fail for now
        if False:
            yield None

    yield from in_style_predication_2(context, state, x_actor_binding, x_object_binding, bound, actor_from_object,
                                      object_from_actor)
~~~

~~~
@Predication(vocabulary,
             names=["solution_group__have_v_1"],
             properties_from=_have_v_1)
def _have_v_1_group(context, state_list, e_list, x_act_list, x_obj_list):
    if state_list.only_one():
        state = state_list[0]
        yield [state.record_operations([RespondOperation("Our menus are ...")])]
~~~

~~~
? What dishes do you have?
Our menus are ...

? What dish do I have?
I don't know
~~~

That's great, but these also work:

~~~
? What dish do you have?
Our menus are ...

? what 3 dishes do you have?
Our menus are ...

? what 900 dishes do you have?
Our menus are ...
~~~

The extra criteria on the variable for dish are not being checked.


### Other meanings
What do we mean by "you" in this case?

"What dishes do you have?" could mean any number of things, including:

- The kind of "dish", as in "what brand is this dish?"
  - If we are talking to a designer and not in the waiter scenario, interpret as: "which types of plates did you buy", then we are talking about dishes as concepts. And we'd give an answer like "The Coronet Red plates"
- Each of the actual plates as instances. 
  - If we are talking to the dishwasher, maybe to see if she has any of a type we need.
- the concept "menu item".
  - If we have not yet described the menu, interpret as "What is on the menu"
- each of the actual instances of that menu item that exists in the world.  As in "oh, you are running out of things? What dishes do you have?"
  - If we have described the menu, interpret as "which instances are left"


Note that, by the time we get to have_v_1, we've lost a lot of context, so we have to just answer the question
`_dish_n_of` will generate 4 distinct sets of solutions:


If only one of these makes sense in the world, you just implement it.  If they all do, but they depend on the situation, only succeed with the one that makes sense at the moment.

So, `have` will get called with x3="you" and x5= each of the possible interpretations of dish.  The first one that works will be returned. So, if all of these *could* work (depending on the context), 

~~~
def _have_v_1(context, state, e_introduced_binding, x_actor_binding, x_object_binding):
    def bound(x_actor, x_object):
        if x_actor != "restaurant":
            # If the user is asking about "what does he/she/I have", etc. 
            # Just say we don't know
            context.report_error(["errorText", "I don't know"])
            return
            
        if is_concept(state, x_object):
            if sort_of(state, x_object, "plate"):
                # Check context and only succeed if:
                # we are talking to a designer and not in the waiter scenario, interpret as: "which types of plates did you buy"
                if not_at_table() and talking_to_designer():
                    # True if actor has this type of thing
                    return rel_check(state, x_actor, "have", x_object)
                    
            elif sort_of(state, x_object, "menu item"):
                # Check context and only succeed if:
                # we have not yet described the menu to this person
                
        else:
            if sort_of(state, x_object, "plate"):
                # Check context and only succeed if:
                # If we are talking to the dishwasher, maybe to see if she has any of a type we need.
                pass
                
            elif sort_of(state, x_object, "menu item"):
                # Check context and only succeed if:
                # If we have described the menu, interpret as "which instances are left"

    def actor_from_object(x_object):
      ...
      
    def object_from_actor(x_actor):
      ...
      
    yield from in_style_predication_2(context, state, x_actor_binding, x_object_binding, bound, actor_from_object,
                                      object_from_actor)
~~~

~~~
def _have_v_1_present_group(context, state_list, e_list, x_act_list, x_obj_list):
    ...
~~~