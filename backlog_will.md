- ESL Architecture
  - Command/Response
    - Scenario: I'd like 2 steaks (at the front door) -> works and it shouldn't
      - Individual solutions succeed with RespondOperations instead of failures
      - Final response is handled by the group predications
        - If it is a single thing, its operation is responded
        - If it is multiple, its operation is overriden by whatever user_wants_multiple returns
    - Seems like a better architecture would be:
      - Let regular predications do basic error checking and logic checking for building up to the verb
        - things like "on" for "on the menu" or "table near the window"
      - The verb itself doesn't do anything except for breaking apart combinatorials and basic validation
      - Let the verb *group* do the heavy lifting
      -
- abstract-types
  - Dealing with multiple people in verbs
    - We don't want to say the same thing twice if it is the same
    - Really, we should put two messages in there and then merge them at the end if they are the same
  - Planning
    - Always returns a single state in the state group
      - Pass the first state in the group and list arguments for the different states
    - Sometimes it is necessary to examine the whole solution group to decide what to do
      - The planner should always get passed a StateGroup
  - Statements about canonical things
    - Problems
      - By the time the verb is executed: How to tell the difference between "any menu" and "the specific menu that is in the variable"
        - Between: "I want the menu", "I want a menu" and "I want the menu my son has"?
        - Both have a specific menu in the variable
    - Scenarios
      - "I want a taxi", can't say "I want *the* taxi"
      - "I want the menu I have heard so much about"
      - "I want two menus/two steaks"
      - "Do you have 2 menus?"
      - "menus from the kitchen are always dirty"
      - "Do you have the blue menu": could be a class of menu or one that just has unusual blue ink on it
      - "I have heard about your menu"
      - "Can I get one of your steaks?"
      - "Can I have the steak?" but not "Can I have the table?"
      - "What is the menu?" but not "what is the table"
      - "What is a menu?" "What is a table?"
      - "Give me a job"
      - "Give me the job"
      - "I'd like a table by the window"
      - "Are there 2 menus here?"
      - "Are 2 children singing 2 songs?"
      - "what is on the menu?"
      - "what is on a menu?"
      - "what is on today's menu?"
      - "How hard is the job?"
      - "we want menus"
    - Analysis
      - There needs to be a way to tell the a difference between the canonical instance of menu for this restaurant "What is on the menu?"
        and one that is generic "what is on a menu?"
        - This is done by putting concepts "in scope".  An in scope menu concept should support "the menu"
      - There needs to be a way to tell the difference between the user indicating a specific instance "Give me the menu my son is holding" and
        a generic instance "give me a menu"
      - For generic instances there might be a lot of extra data with them: 
        "I want the menu I have heard so much about"
        "I want 2 menus"
      - Sometimes extra data can be used to select a type: 
        - "tell me about today's menu" should select the type that is for "today"
        - "what is on your prix fixe menu?"
      - Sometimes the extra data needs to be carried along:
        - "give me 2 menus, please!"
          - 2 should not filter the menus but should be part of the data
      - Quantifiers shouldn't filter out abstract items. Even though "I want the taxi" seems like it could only be an instance
        in a restaurant where "the taxi" is a burger choice it could be abstract
    - Design
      - The developer is going to get all the variations of solutions, they need to decide which is right
      - nouns should always return types and instances
      - just like instances, types can be:
        - in or out of scope
        - Filtered by other words in the phrase
      - types can collect data as they are modified as in "give me today's menu"
        - If that solution is used by the filtered data isn't, it should fail? Like if a word isn't understood?
      - How does a predication like today() decide whether to add data or filter
        - Probably this should be two solutions?
        - And downstream predicates decide how to deal with it?
      - Phase 2 will deliver solutions where there is only the abstract instance in a variable and pass along the criteria
        The developer needs to build up the right solution group by checking the context of the phrase and deciding whether to use the abstract version
        or fail the group with the abstract version and wait for the instances solution group
        - If they decide to use the abstract version, they need to be careful to properly check criteria so that
    - Questions
      - Are canonical instances and types different?
        - Let's say no, since there doesn't seem to be anything to distinguish them
      - Is scoping built into the system or on top?
     - Implementation
        - (done) Implement a generic way to see if something is an abstract type
          - hasattr("is_abstract")
        - (done) Abstract types should not get mixed in with other types *in the same variable*
          - This should fail in add_solution()
        - (done) meets_criteria() should just return "true" if the variable is an abstract type
        - (done) add_solution() currently checks *either* collective *or* cuml/dist
          - It should have a different set of checks if the previous variable is abstract:
            - This variables values meets the criteria, it is collective or cuml
            - This variables values could be divided such that it meets the criteria, evenly with no remainder, it is dist
            - Also: if *this* variable is conceptual, it is going to match *all three* potential plural types
        - (done) Update abstract variables to use new Concept() object
        - (done) Have a way for predications like "for" to add information to Concept variables
        - Need a way to get the constraints for a variable in the group hanlder.  Options:
          - Force the developer to ask
          - Pass as an argument
        - The developer will have to ensure that abstract variables meet global constraints
        - The developer will have to see which kind of solution group this is: a cuml/coll group or a dist group
        - The developer will have divide up the group however makes sense
        - It *might* be helpful to have the system indicate which type of group a variable is
        - Implement table fully
          - How to deal with 2 tables vs "the table" vs 3 tables?
          - Seems like there should be a way to say "This is what we have, this is what was required"
            what is the answer, if any?
        - Implement menu fully
        - Make pronouns implement abstract types?
        - Issues:
          - combinatoric logic also needs to not mix conceptual and instances
            - TODO: Might be easier to just prevent conceptual in combinatoric
          - Conceptual instances can come through in any order, if you want conceptual you 
            might need to wait for it
          - Need a way to return errors from the plan that get shown to the user
            for scenarios like "we don't allow specific tables"
          - Something that processes a concept needs to understand all of it or fail
            - How to enforce this?


- Redo existing code using Perplexity ontology
- Implement all nouns in terms of base engine using noun_n()
- Implement "I want ham"
- Dealing with all the duplication of items and combinatorics seems like a waste. Seems like there must be a better way that involves symbolics. For example
  - We want a steak
  - If there are 10 steaks, then want_v_1 will get called 20 times (10 for each person). Whereas if "steak" was symbolic it would only get called twice