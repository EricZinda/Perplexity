- ESL Architecture
  - Command/Response
    - Scenario: I'd like 2 steaks (at the front door) -> works and it shouldn't
      - Individual solutions succeed with RespondOperations instead of failures
      - Final response is handled by the group predications
        - If it is a single thing, its operation is responded
        - If it is multiple, its operation is overriden by whatever user_wants_multiple returns
    - Seems like a better architecture would be:
      - Let regular predications do basic error checking and logic checking for building up to the verb
        - things like "on" for "on the menu" or "table near the window"
      - The verb itself doesn't do anything except for breaking apart combinatorials and basic validation
      - Let the verb *group* do the heavy lifting
  - Dealing with multiple people in verbs
    - We don't want to say the same thing twice if it is the same
    - Really, we should put two messages in there and then merge them at the end if they are the same
  - Planning
    - Always returns a single state in the state group
      - Pass the first state in the group and list arguments for the different states
    - Sometimes it is necessary to examine the whole solution group to decide what to do
      - The planner should always get passed a StateGroup

- Redo existing code using Perplexity ontology
- Implement all nouns in terms of base engine using noun_n()
- Implement "I want ham"
- Dealing with all the duplication of items and combinatorics seems like a waste. Seems like there must be a better way that involves symbolics. For example
  - We want a steak
  - If there are 10 steaks, then want_v_1 will get called 20 times (10 for each person). Whereas if "steak" was symbolic it would only get called twice